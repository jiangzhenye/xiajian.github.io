---
layout: post
title: Rack学习笔记
---

## 缘起
----

最初学习Ruby和Rails时，看到过Rack，顺便还不知从拿收集一个《Rack编程》的PDF文档。最来，学习Grape，顺带学习一下Rack，加强加强基础。

## 正文

最简单的Rack程序就是一个包含`call`方法调用的Ruby对象(lambda/proc,method,包含call方法的类)，接受参数(HTTP请求)，返回包含三个元素的数组(HTTP响应)。

Rack是Ruby应用服务器和Rack应用程序之间的一个接口。应用服务器，反向代理，Rack::Handler名称空间：

```ruby
Rack::Handler::CGI
Rack::Handler::EventedMongrel
Rack::Handler::FastCGI
Rack::Handler::LSWS
Rack::Handler::Mongrel
Rack::Handler::SCGI
Rack::Handler::SwiftipliedMongrel
Rack::Handler::Thin
Rack::Handler::WEBrick
```

> 所有的Rack Handler都有一个run方法

Rails和Sinatra都是Rack程序。

[Rack spec文档](http://www.rubydoc.info/github/rack/rack/master/file/SPEC)

中间件 - 最大程序的模块化，web应用程序部件。

可被调用的对象：环境对象参数，返回的三个数组(状态，头，体)

符合条件的Rack应用程序: 

```ruby
irb> rack_app = lambda {|env| [200,{},["hello from lambda"]]}
irb> Rack::Handler::WEBrick.run rack_app ,:Port=>3000 # 运行之后，我的IRB进程就挂了
irb> Rack::Handler::Thin.run rack_app ,:Port=>3000
```

Rack的实例，具体介绍如下:
```ruby
#!/usr/bin/env ruby
require "rubygems"
require "rack"
def pp(hash)
  hash.map {|key,value|  "#{key} => #{value}" }.sort.join("\n")
end

Rack::Handler::WEBrick.run lambda {|env| [200,{},[pp(env)]]} , :Port=>8000
```

输入: http://localhost:8000/xiajin%20e%20we

响应结果: 

    GATEWAY_INTERFACE => CGI/1.1
    HTTP_ACCEPT => text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    HTTP_ACCEPT_ENCODING => gzip, deflate
    HTTP_ACCEPT_LANGUAGE => en-US,en;q=0.5
    HTTP_CACHE_CONTROL => max-age=0
    HTTP_CONNECTION => keep-alive  # HTTP连接的类型
    HTTP_COOKIE => optimizelySegments=%7B%22326765800%22%3A%22false%22%2C%22326352497%22%3A%22direct%22%2C%22327219662%22%3A%22ff%22%2C%22532690232%22%3A%22none%22%7D; optimizelyEndUserId=oeu1405064745904r0.9964926734400492; optimizelyBuckets=%7B%7D; CNZZDATA17872=cnzz_eid%3D1643098070-1408757496-%26ntime%3D1408757496; __atuvc=1%7C34
    HTTP_DNT => 1
    HTTP_HOST => localhost:8000
    HTTP_USER_AGENT => Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0
    HTTP_VERSION => HTTP/1.1
    PATH_INFO => /xiajin%20e%20we  #实现路由算法的关键
    QUERY_STRING =>  #查询字符串
    REMOTE_ADDR => 127.0.0.1
    REMOTE_HOST => 127.0.0.1
    REQUEST_METHOD => GET  # HTTP请求
    REQUEST_PATH => /xiajin%20e%20we
    REQUEST_URI => http://localhost:8000/xiajin%20e%20we
    SCRIPT_NAME => 
    SERVER_NAME => localhost
    SERVER_PORT => 8000
    SERVER_PROTOCOL => HTTP/1.1
    SERVER_SOFTWARE => WEBrick/1.3.1 (Ruby/1.9.3/2014-05-14)
    rack.errors => #<IO:0x00000000bcc258>
    rack.input => #<StringIO:0x00000000ea77c0>
    rack.multiprocess => false
    rack.multithread => true
    rack.run_once => false
    rack.url_scheme => http
    rack.version => [1, 1]


