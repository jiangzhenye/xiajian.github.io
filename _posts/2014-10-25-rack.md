---
layout: post
title: Rack学习笔记
---

## 缘起
----

最初学习Ruby和Rails时，看到过Rack，顺便还不知从拿收集一个《Rack编程》的PDF文档。最来，学习Grape，顺带学习一下Rack，加强加强基础。

## 正文

最简单的Rack程序就是一个包含`call`方法调用的Ruby对象(lambda/proc,method,包含call方法的类)，接受参数(HTTP请求)，返回包含三个元素的数组(HTTP响应)。

Rack是Ruby应用服务器和Rack应用程序之间的一个接口。应用服务器，反向代理，Rack::Handler名称空间：

```ruby
Rack::Handler::CGI
Rack::Handler::EventedMongrel
Rack::Handler::FastCGI
Rack::Handler::LSWS
Rack::Handler::Mongrel
Rack::Handler::SCGI
Rack::Handler::SwiftipliedMongrel
Rack::Handler::Thin
Rack::Handler::WEBrick
```

> 所有的Rack Handler都有一个run方法 Rails和Sinatra都是Rack程序。 [Rack spec文档](http://www.rubydoc.info/github/rack/rack/master/file/SPEC)

中间件 - 最大程序的模块化，web应用程序部件。

可被调用的对象：环境对象参数，返回的三个数组(状态，头，体)

符合条件的Rack应用程序: 

```ruby
irb> rack_app = lambda {|env| [200,{},["hello from lambda"]]}
irb> Rack::Handler::WEBrick.run rack_app ,:Port=>3000 # 运行之后，我的IRB进程就挂了
irb> Rack::Handler::Thin.run rack_app ,:Port=>3000
```

Rack的实例，具体介绍如下:
```ruby
#!/usr/bin/env ruby
require "rubygems"
require "rack"
def pp(hash)
  hash.map {|key,value|  "#{key} => #{value}" }.sort.join("\n")
end

Rack::Handler::WEBrick.run lambda {|env| [200,{},[pp(env)]]} , :Port=>8000
```

输入: http://localhost:8000/xiajin%20e%20we

响应结果: 

    GATEWAY_INTERFACE => CGI/1.1
    HTTP_ACCEPT => text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    HTTP_ACCEPT_ENCODING => gzip, deflate
    HTTP_ACCEPT_LANGUAGE => en-US,en;q=0.5
    HTTP_CACHE_CONTROL => max-age=0
    HTTP_CONNECTION => keep-alive  # HTTP连接的类型
    HTTP_COOKIE => optimizelySegments=%7B%22326765800%22%3A%22false%22%2C%22326352497%22%3A%22direct%22%2C%22327219662%22%3A%22ff%22%2C%22532690232%22%3A%22none%22%7D; optimizelyEndUserId=oeu1405064745904r0.9964926734400492; optimizelyBuckets=%7B%7D; CNZZDATA17872=cnzz_eid%3D1643098070-1408757496-%26ntime%3D1408757496; __atuvc=1%7C34
    HTTP_DNT => 1
    HTTP_HOST => localhost:8000
    HTTP_USER_AGENT => Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0
    HTTP_VERSION => HTTP/1.1
    PATH_INFO => /xiajin%20e%20we  #实现路由算法的关键
    QUERY_STRING =>  #查询字符串
    REMOTE_ADDR => 127.0.0.1
    REMOTE_HOST => 127.0.0.1
    REQUEST_METHOD => GET  # HTTP请求
    REQUEST_PATH => /xiajin%20e%20we
    REQUEST_URI => http://localhost:8000/xiajin%20e%20we
    SCRIPT_NAME => 
    SERVER_NAME => localhost
    SERVER_PORT => 8000
    SERVER_PROTOCOL => HTTP/1.1
    SERVER_SOFTWARE => WEBrick/1.3.1 (Ruby/1.9.3/2014-05-14)
    rack.errors => #<IO:0x00000000bcc258>
    rack.input => #<StringIO:0x00000000ea77c0>
    rack.multiprocess => false
    rack.multithread => true
    rack.run_once => false
    rack.url_scheme => http
    rack.version => [1, 1]

## 中间件

中间件就是Ruby应用服务器和Rack应用程序之间执行的代码。用来分离耦合，将处理和包装进行分离，可以实现通用逻辑和业务逻辑分离。

call方法: 

**状态码**: HTTP状态，to_i产生整数，大于100

**响应头**: 必须能响应each方法，产生key/value，key和value必须是字符串，任何时候必须包含的key: Content-Type 内容类型, Content-Length 内容长度。

**响应体**: 响应each方法，产生字符串。1.9不支持each方法。

用户身份认证的中间件，应用到任何Rack应用程序中，Web框架-Rack应用程序-中间件。中间件包装中间件，单片实现的框架分离成多个中间件的好处： 1. 中间件独立发展 2. 不同的方式组合中间件 - 过滤器 

### 装配中间件

- 方法一：使用new方法 - `Rack::Handler::XXXX.run Middleware1.new(Middleware2.new(rack_app[,options2])[,options1])`

- 方法二：使用DSL进行描述， 比如定义Builder类：

```ruby
class Builder
  def use
    # ...
  end

  def run
    # ...
  end
end
```
使用DSL的方式:

```ruby
Builder.new {
  use Middleware1
  use Middleware2
  run Rack Application
}
```

尝试编写了一些加载中间件的DSL，实现不是特别的困难: 

```ruby
class Builder
  def initialize(&block)
    @middlewares = []
    self.instance_eval(&block)  # 对传递过来的代码进行求值
  end

  def use(middleware_class, *options, &block)  # 在数组中保存lambda
    @middlewares << lambda { |app| middleware_class.new(app, *options, &block)}
  end

  def run(app)
    @app = app
  end

  def to_app
    @middlewares.reverse.inject(@app) { |app,middleware| middleware.call(app) }
  end
end
```

Rack中提供了类似上面描述的Builder，其中还利用了Rack::URLMap处理路由。

## 最简web框架

Rack为web程序及框架提供了很多有用的设施。Request和Response的存取，路由处理，cookie信息，Session信息，日志。Rack自带框架- rackup。

### 路由

web程序使用不同的代码处理不同的URL，对应关系处理 - 路由 - 路径和代码块的一一对应。\

路由的实现: use和run方法，map的定义: 

```ruby
def map(path, &block)
  if @ins.last.kind_of? Hash
    @ins.last[path] = self.class.new(&block).to_app
  else
    @ins << {}
    map(path, &block)  # 注意这里的递归调用，递归意味着了嵌套
  end
end
```

所以，如下就是一个嵌套的例子: 

```ruby
#!/usr/bin/env ruby
require "rubygems"
require 'rack'

app = Rack::Builder.new do
  use Rack::ContentLength
  map '/hello' do
    use Rack::CommonLogger
    map '/ketty' do
      run lambda { |env| [200, {"Content-Type" => "text/html"} , 
                          ["from hello-ketty", 
                           "SCRIPT_NAME=#{env['SCRIPT_NAME']}",
                           "PATH_INFO=#{env['PATH_INFO']}"]]}
    end
    map '/everyone' do 
      run lambda { |env| [200, {"Content-Type" => "text/html"},
                          ["from hello-everyone",
                           "SCRIPT_NAME=#{env['SCRIPT_NAME']}",
                           "PATH_INFO=#{env['PATH_INFO']}"]] }
    end
    
    map '/' do
      run lambda { |env| [200, {"Content-Type" => "text/html"}, 
                          ["from hello catch all",
                           "SCRIPT_NAME=#{env['SCRIPT_NAME']}",
                           "PATH_INFO=#{env['PATH_INFO']}"]] }
    end
  end
  map '/world' do 
    run lambda { |env| [200, {"Content-Type" => "text/html"}, ["world"]] }
  end
  map '/' do 
    run lambda { |env| [200, {"Content-Type" => "text/html"}, ["here"]] }
  end
end

Rack::Handler::Thin.run app, :Port => 5000  # 运行应用的处理器
```

### Rackup

rackup命令，使用配置文件(config.ru)运行应用程序。`rack config.ru`命令所做的事情相当于： 

    app = Rack::Builder.new { ... 配置文件 ... }.to_app

rackup运行web服务器和端口的方式: `rackup -s thin -p 3000`

Rackup实现很简单: `Rack::Server.start`，`Rack::Server`是重点，其接口实现如下： 

```ruby
module Rack
  class Server
    def self.start                 # 类方法
    def self.middleware

    def initialize(options = nil)  # 构造函数
    def options
    def app
    def middleware
    def start
    def server
  end
end
```

