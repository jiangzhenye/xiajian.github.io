---
layout: post
title: 关于resque
description: "ruby, resque"
---

## 前言

果然服务器端最先开始的是要搞后台任务，刚好又同redis扯上关系，这真是天赐良机啊，果断一起搞。

项目中的resque相关的gem包如下: 

* [resque](https://github.com/resque/resque), 很重要的，简介为：用于创建后台任务的基于Redis的Ruby库，其将任务放置到多个队列中，并用于随后的处理。
* [redis-namespace](https://github.com/resque/redis-namespace) 
* [resque-scheduler](https://github.com/resque/resque-scheduler), 任务安排相关。
* [rufus-scheduler](https://github.com/resque/resque-loner), ruby的任务安排, resque-scheduler的依赖项
* [resque-loner](https://github.com/resque/resque-loner), 支持在resque中的特殊任务
* [resque_mailer](https://github.com/zapnap/resque_mailer), 邮件任务
* [capistrano-resque](https://github.com/sshingler/capistrano-resque), 部署任务相关

## resque

Resque是用来创建后台任务的基于Redis的库，其将任务放到多个队列中，并稍后处理。

后台任务是可以是任何响应`perform`方法的Ruby类或者模型。已存在的类可以很容易的转换成后台任务。
创建一个新类处理特定的job或者直接在已有的类中添加，都是可行的。

Resque受[DelayedJob](https://github.com/collectiveidea/delayed_job)启发，并由三个部件组成: 

1. 创建、查询和处理jobs的Ruby库
2. 启动worker进程，处理任务的Rake任务
3. 监视队列、jobs以及worker进程的Sinatra App

Resque的工作进程可以分布在不同的机器之间，支持优先级，弹性处理内存(bloat)/泄漏，针对
REE优化(即所谓的copy on write)，自行通知，以及失效期望。

Resque队列可持久化，支持固定时间的原子推送和弹出(感谢Redis)，提供内容的可视化，以及可将
jobs存储成简单的JSON包。

Resque前端展示工作进程做了什么，没做什么，那些在队列，那些在队列，提供通用的使用状态，并辅助追踪失效队列。

### Resque的背景

Github尝试了各种各样的后台任务: SQS, ActiveMessaging, BackgroundJob 

- SQS, 资源限制，存在时延，放弃
- ActiveMessaging, 太复杂，延续了Rails框架的设计
- BackgroundJob, 加载整个Rails环境很慢，耗时且CPU计算大
- DelayedJob, 类似BackgroundJob， 数据库支持的队列以及优先级。带有持久化(yaml持久化)的工作进程，
  仅在启动的加载Rails，在循环中处理jobs

最后，Github列出自己对后台任务的需求: 

- 持久化
- 观察等待的进程
- 即时修改等待进程
- tag
- 优先级
- 快速推送和弹出
- 观察完成的任务和正在做的任务
- 干掉过分臃肿的，陈旧的，运行时间过长的工作进程
- 保持Rails加载和持久化的进程。
- 分布式且可参考多个标签的工作进程
- 不重试不释放失效的进程

Redis的特征和特性: 

* Atomic, O(1) list push and pop
* Ability to paginate over lists without mutating them
* Queryable keyspace, high visibility
* Fast
* Easy to install - no dependencies
* Reliable Ruby client library
* Store arbitrary strings
* Support for integer counters
* Persistent
* Master-slave replication
* Network aware

使用Redis处理队列问题，Resque关注工作进程的问题: 可见性，可靠性以及状态。


### 概述

在Resque中，创建jobs并将其放到队列中，然后，从队列中弹出jobs并处理。

Resque任务是响应`perform`方法的Ruby类或模块，如下是个简单的例子:

``` ruby
class Archive
  @queue = :file_serve

  def self.perform(repo_id, branch = 'master')
    repo = Repository.find(repo_id)
    repo.create_archive(branch)
  end
end
```

`@queue`类实例变量决定了`Archive`任务放置的队列。队列是任意的，且即刻创建。随即命名，任意数目。

为了将`Archive`任务放置到`file_serve`队列中，可将其添加到应用中已存在的`Repository`类中: 

``` ruby
class Repository
  def async_create_archive(branch)
    Resque.enqueue(Archive, self.id, branch) # 将任务插入队列
  end
end
```
> 原来，下载代码库的tarball是后台任务。此外，fork和create repo都是后台任务。

当在应用中调用`repo.async_create_archive('masterbrew')`时，就会创建一个job并将其放置到
`file_serve`队列中。

最后，将会启动一个worker进程，运行类似如下的代码处理: 

``` ruby
klass, args = Resque.reserve(:file_serve) # 从队列中提取任务
klass.perform(*args) if klass.respond_to? :perform
```

上述代码等价于:

``` ruby
Archive.perform(44, 'masterbrew')
```

启动一个工作进程，并运行的`file_serve`任务代码如下: 

    $ cd app_root
    $ QUEUE=file_serve rake resque:work  # 使用rake任务启动工作进程

上述代码启动了Resque worker进程，并告知其处理`file_serve`队列上的任务。一旦运行上述
`Resque.reserve`代码片段，就会一直处理到全部结束，休眠一段时间，重复的从队列中获取
更多的任务。

Workers can be given multiple queues (a "queue list") and run on
multiple machines. In fact they can be run anywhere with network
access to the Redis server.

Workers可以给定多个队列(队列表)，并运行在多个机器上。实际，其可运行在Redis
服务器可访问的任何地方。

### 任务

什么应该运行在后台? 任何费时的事物，比如，缓慢的插入语句，磁盘操作，数据处理等等。

Github中使用Resque处理如下类型的任务: 

* Warming caches
* Counting disk usage
* Building tarballs
* Building Rubygems
* Firing off web hooks
* Creating events in the db and pre-caching them
* Building graphs
* Deleting users
* Updating our search index - 更新搜索索引也用后台任务??

至今为止，Github中已有35个不同类型的后台任务。

注意：并不需要一个web app来运行Resque - 前台后台的区分仅仅是为了概念上的描述清晰。可以将爬站和粘数据
的处理放到队列中。

**Persistence**

任务可以持久化为JSON对象，以`Archive`为例，运行如下代码创建job，

``` ruby
repo = Repository.find(44)
repo.async_create_archive('masterbrew')
```

如下的JSON数据将会被存储在`file_serve`队列中: 

``` javascript
{
    'class': 'Archive',
    'args': [ 44, 'masterbrew' ]
}
```

Because of this your jobs must only accept arguments that can be JSON encoded.

由于Job必须要将接受的参数进行json编码，所以，不能使用`Resque.enqueue(Archive, self, branch)`，而应该
使用`Resque.enqueue(Archive, self.id, branch)`的调用方式。

这也是为何例子中使用对象id而不是传递整个对象的原因: 

使用对象ID，并重数据库或缓存中获取数据并非约定，但相比封装对象有一点优势：
封装对象存在使用带有过时信息的陈旧记录。

**send_later / async**

延后发送在例子(`examples/`)中有所介绍，异步处理则在以后的发布会提供。

Want something like DelayedJob's `send_later` or the ability to use
instance methods instead of just methods for jobs? See the `examples/`
directory for goodies.

We plan to provide first class `async` support in a future release.


**Failure**

If a job raises an exception, it is logged and handed off to the
`Resque::Failure` module. Failures are logged either locally in Redis
or using some different backend.

For example, Resque ships with [Airbrake](https://github.com/airbrake/airbrake) support.

Keep this in mind when writing your jobs: you may want to throw
exceptions you would not normally throw in order to assist debugging.


### Workers

Resque任务是永远运行的Rake任务，其基本结构如下: 

``` ruby
start
loop do
  if job = reserve
    job.process
  else
    sleep 5 # Polling frequency = 5
  end
end
shutdown
```

启动工作进程非常简单，具体例子如下: 

    $ QUEUE=file_serve rake resque:work

默认情况下，Resque并不知道应用的环境，这意味着其不能发现并运行jobs，它
需要将整个应用加载到内存中。

若将Resque安装成Rails的插件，需要在RAILS_ROOT目录下运行如下命令：

    $ QUEUE=file_serve rake environment resque:work

This will load the environment before starting a worker. Alternately
we can define a `resque:setup` task with a dependency on the
`environment` rake task:

``` ruby
task "resque:setup" => :environment
```

GitHub's setup task looks like this:

``` ruby
task "resque:setup" => :environment do
  Grit::Git.git_timeout = 10.minutes
end
```

We don't want the `git_timeout` as high as 10 minutes in our web app,
but in the Resque workers it's fine.

**Logging**

Workers support basic logging to STDOUT. If you start them with the
`VERBOSE` env variable set, they will print basic debugging
information. You can also set the `VVERBOSE` (very verbose) env
variable.

    $ VVERBOSE=1 QUEUE=file_serve rake environment resque:work

**Process IDs (PIDs)**

There are scenarios where it's helpful to record the PID of a resque
worker process.  Use the PIDFILE option for easy access to the PID:

    $ PIDFILE=./resque.pid QUEUE=file_serve rake environment resque:work

**Running in the background**

(Only supported with ruby >= 1.9). There are scenarios where it's helpful for
the resque worker to run itself in the background (usually in combination with
PIDFILE).  Use the BACKGROUND option so that rake will return as soon as the
worker is started.

    $ PIDFILE=./resque.pid BACKGROUND=yes QUEUE=file_serve \
        rake environment resque:work

**Polling frequency**

You can pass an INTERVAL option which is a float representing the polling frequency.
The default is 5 seconds, but for a semi-active app you may want to use a smaller value.

    $ INTERVAL=0.1 QUEUE=file_serve rake environment resque:work

### Priorities and Queue Lists

Resque doesn't support numeric priorities but instead uses the order
of queues you give it. We call this list of queues the "queue list."

Let's say we add a `warm_cache` queue in addition to our `file_serve`
queue. We'd now start a worker like so:

    $ QUEUES=file_serve,warm_cache rake resque:work

When the worker looks for new jobs, it will first check
`file_serve`. If it finds a job, it'll process it then check
`file_serve` again. It will keep checking `file_serve` until no more
jobs are available. At that point, it will check `warm_cache`. If it
finds a job it'll process it then check `file_serve` (repeating the
whole process).

In this way you can prioritize certain queues. At GitHub we start our
workers with something like this:

    $ QUEUES=critical,archive,high,low rake resque:work

Notice the `archive` queue - it is specialized and in our future
architecture will only be run from a single machine.

At that point we'll start workers on our generalized background
machines with this command:

    $ QUEUES=critical,high,low rake resque:work

And workers on our specialized archive machine with this command:

    $ QUEUE=archive rake resque:work


**Running All Queues**

If you want your workers to work off of every queue, including new
queues created on the fly, you can use a splat:

    $ QUEUE=* rake resque:work

Queues will be processed in alphabetical order.

**Running Multiple Workers**

At GitHub we use god to start and stop multiple workers. A sample god
configuration file is included under `examples/god`. We recommend this
method.

If you'd like to run multiple workers in development mode, you can do
so using the `resque:workers` rake task:

    $ COUNT=5 QUEUE=* rake resque:workers

This will spawn five Resque workers, each in its own process. Hitting
ctrl-c should be sufficient to stop them all.


** Forking**

On certain platforms, when a Resque worker reserves a job it
immediately forks a child process. The child processes the job then
exits. When the child has exited successfully, the worker reserves
another job and repeats the process.

Why?

Because Resque assumes chaos.

Resque assumes your background workers will lock up, run too long, or
have unwanted memory growth.

If Resque workers processed jobs themselves, it'd be hard to whip them
into shape. Let's say one is using too much memory: you send it a
signal that says "shutdown after you finish processing the current
job," and it does so. It then starts up again - loading your entire
application environment. This adds useless CPU cycles and causes a
delay in queue processing.

Plus, what if it's using too much memory and has stopped responding to
signals?

Thanks to Resque's parent / child architecture, jobs that use too much memory
release that memory upon completion. No unwanted growth.

And what if a job is running too long? You'd need to `kill -9` it then
start the worker again. With Resque's parent / child architecture you
can tell the parent to forcefully kill the child then immediately
start processing more jobs. No startup delay or wasted cycles.

The parent / child architecture helps us keep tabs on what workers are
doing, too. By eliminating the need to `kill -9` workers we can have
parents remove themselves from the global listing of workers. If we
just ruthlessly killed workers, we'd need a separate watchdog process
to add and remove them to the global listing - which becomes
complicated.

Workers instead handle their own state.

**Parents and Children**

Here's a parent / child pair doing some work:

    $ ps -e -o pid,command | grep [r]esque
    92099 resque: Forked 92102 at 1253142769
    92102 resque: Processing file_serve since 1253142769

You can clearly see that process 92099 forked 92102, which has been
working since 1253142769.

(By advertising the time they began processing you can easily use monit
or god to kill stale workers.)

When a parent process is idle, it lets you know what queues it is
waiting for work on:

    $ ps -e -o pid,command | grep [r]esque
    92099 resque: Waiting for file_serve,warm_cache


**Signals**

Resque workers respond to a few different signals:

* `QUIT` - Wait for child to finish processing then exit
* `TERM` / `INT` - Immediately kill child then exit
* `USR1` - Immediately kill child but don't exit
* `USR2` - Don't start to process any new jobs
* `CONT` - Start to process new jobs again after a USR2

If you want to gracefully shutdown a Resque worker, use `QUIT`.

If you want to kill a stale or stuck child, use `USR1`. Processing
will continue as normal unless the child was not found. In that case
Resque assumes the parent process is in a bad state and shuts down.

If you want to kill a stale or stuck child and shutdown, use `TERM`

If you want to stop processing jobs, but want to leave the worker running
(for example, to temporarily alleviate load), use `USR2` to stop processing,
then `CONT` to start it again.

**Mysql::Error: MySQL server has gone away**

If your workers remain idle for too long they may lose their MySQL
connection. If that happens we recommend using [this
Gist](http://gist.github.com/238999).


### 前端

Resque自带了一个基于Sinatra的前端，用来查看队列的状态。其可单独使用，也可与其他的东西进行集成。

**单独使用**

If you've installed Resque as a gem running the front end standalone is easy:

    $ resque-web

It's a thin layer around `rackup` so it's configurable as well:

    $ resque-web -p 8282

If you have a Resque config file you want evaluated just pass it to
the script as the final argument:

    $ resque-web -p 8282 rails_root/config/initializers/resque.rb

You can also set the namespace directly using `resque-web`:

    $ resque-web -p 8282 -N myapp

or set the Redis connection string if you need to do something like select a different database:

    $ resque-web -p 8282 -r localhost:6379:2

安装resque gem包后，就会存在`resque-web`命令工具。

**与Passenger配合**

Using Passenger? Resque ships with a `config.ru` you can use. See
Phusion's guide:

Apache: <http://www.modrails.com/documentation/Users%20guide%20Apache.html#_deploying_a_rack_based_ruby_application>
Nginx: <http://www.modrails.com/documentation/Users%20guide%20Nginx.html#deploying_a_rack_app>

**Rack::URLMap**

If you want to load Resque on a subpath, possibly alongside other
apps, it's easy to do with Rack's `URLMap`:

``` ruby
require 'resque/server'

run Rack::URLMap.new \
  "/"       => Your::App.new,
  "/resque" => Resque::Server.new
```

Check `examples/demo/config.ru` for a functional example (including HTTP basic auth).

**与Rails 3集成**

You can also mount Resque on a subpath in your existing Rails 3 app by adding `require 'resque/server'` to the top of your routes file or in an initializer then adding this to `routes.rb`:

``` ruby
mount Resque::Server.new, :at => "/resque"
```

## Resque vs DelayedJob

How does Resque compare to DelayedJob, and why would you choose one
over the other?

* Resque supports multiple queues
* DelayedJob supports finer grained priorities
* Resque workers are resilient to memory leaks / bloat
* DelayedJob workers are extremely simple and easy to modify
* Resque requires Redis
* DelayedJob requires ActiveRecord
* Resque can only place JSONable Ruby objects on a queue as arguments
* DelayedJob can place _any_ Ruby object on its queue as arguments
* Resque includes a Sinatra app for monitoring what's going on
* DelayedJob can be queried from within your Rails app if you want to
  add an interface

If you're doing Rails development, you already have a database and
ActiveRecord. DelayedJob is super easy to setup and works great.
GitHub used it for many months to process almost 200 million jobs.

Choose Resque if:

* You need multiple queues
* You don't care / dislike numeric priorities
* You don't need to persist every Ruby object ever
* You have potentially huge queues
* You want to see what's going on
* You expect a lot of failure / chaos
* You can setup Redis
* You're not running short on RAM

Choose DelayedJob if:

* You like numeric priorities
* You're not doing a gigantic amount of jobs each day
* Your queue stays small and nimble
* There is not a lot failure / chaos
* You want to easily throw anything on the queue
* You don't want to setup Redis

In no way is Resque a "better" DelayedJob, so make sure you pick the
tool that's best for your app.

## Resque Dependencies

    $ gem install bundler
    $ bundle install

## Installing Resque

### In a Rack app, as a gem

First install the gem.

    $ gem install resque

Next include it in your application.

``` ruby
require 'resque'
```

Now start your application:

    rackup config.ru

That's it! You can now create Resque jobs from within your app.

To start a worker, create a Rakefile in your app's root (or add this
to an existing Rakefile):

``` ruby
require 'your/app'
require 'resque/tasks'
```

Now:

    $ QUEUE=* rake resque:work

Alternately you can define a `resque:setup` hook in your Rakefile if you
don't want to load your app every time rake runs.


### In a Rails 2.x app, as a gem

First install the gem.

    $ gem install resque

Next include it in your application.

    $ cat config/initializers/load_resque.rb
    require 'resque'

Now start your application:

    $ ./script/server

That's it! You can now create Resque jobs from within your app.

To start a worker, add this to your Rakefile in `RAILS_ROOT`:

``` ruby
require 'resque/tasks'
```

Now:

    $ QUEUE=* rake environment resque:work

Don't forget you can define a `resque:setup` hook in
`lib/tasks/whatever.rake` that loads the `environment` task every time.


### In a Rails 2.x app, as a plugin

    $ ./script/plugin install git://github.com/resque/resque

That's it! Resque will automatically be available when your Rails app
loads.

To start a worker:

    $ QUEUE=* rake environment resque:work

Don't forget you can define a `resque:setup` hook in
`lib/tasks/whatever.rake` that loads the `environment` task every time.


### In a Rails 3 app, as a gem

First include it in your Gemfile.

    $ cat Gemfile
    ...
    gem 'resque'
    ...

Next install it with Bundler.

    $ bundle install

Now start your application:

    $ rails server

That's it! You can now create Resque jobs from within your app.

To start a worker, add this to a file in `lib/tasks` (ex:
`lib/tasks/resque.rake`):

``` ruby
require 'resque/tasks'
```

Now:

    $ QUEUE=* rake environment resque:work

Don't forget you can define a `resque:setup` hook in
`lib/tasks/whatever.rake` that loads the `environment` task every time.


## Configuration

You may want to change the Redis host and port Resque connects to, or
set various other options at startup.

Resque has a `redis` setter which can be given a string or a Redis
object. This means if you're already using Redis in your app, Resque
can re-use the existing connection.

String: `Resque.redis = 'localhost:6379'`

Redis: `Resque.redis = $redis`

For our rails app we have a `config/initializers/resque.rb` file where
we load `config/resque.yml` by hand and set the Redis information
appropriately.

Here's our `config/resque.yml`:

    development: localhost:6379
    test: localhost:6379
    staging: redis1.se.github.com:6379
    fi: localhost:6379
    production: redis1.ae.github.com:6379

And our initializer:

``` ruby
rails_root = ENV['RAILS_ROOT'] || File.dirname(__FILE__) + '/../..'
rails_env = ENV['RAILS_ENV'] || 'development'

resque_config = YAML.load_file(rails_root + '/config/resque.yml')
Resque.redis = resque_config[rails_env]
```

Easy peasy! Why not just use `RAILS_ROOT` and `RAILS_ENV`? Because
this way we can tell our Sinatra app about the config file:

    $ RAILS_ENV=production resque-web rails_root/config/initializers/resque.rb

Now everyone is on the same page.

Also, you could disable jobs queueing by setting 'inline' attribute.
For example, if you want to run all jobs in the same process for cucumber, try:

``` ruby
Resque.inline = ENV['RAILS_ENV'] == "cucumber"
```

## Plugins and Hooks

For a list of available plugins see
<http://wiki.github.com/resque/resque/plugins>.

If you'd like to write your own plugin, or want to customize Resque
using hooks (such as `Resque.after_fork`), see
[docs/HOOKS.md](http://github.com/resque/resque/blob/master/docs/HOOKS.md).


## Namespaces

If you're running multiple, separate instances of Resque you may want
to namespace the keyspaces so they do not overlap. This is not unlike
the approach taken by many memcached clients.

This feature is provided by the [redis-namespace][rs] library, which
Resque uses by default to separate the keys it manages from other keys
in your Redis server.

Simply use the `Resque.redis.namespace` accessor:

``` ruby
Resque.redis.namespace = "resque:GitHub"
```

We recommend sticking this in your initializer somewhere after Redis
is configured.


## Demo

Resque ships with a demo Sinatra app for creating jobs that are later
processed in the background.

Try it out by looking at the README, found at `examples/demo/README.markdown`.


## Monitoring

### god

If you're using god to monitor Resque, we have provided example
configs in `examples/god/`. One is for starting / stopping workers,
the other is for killing workers that have been running too long.

### monit

If you're using monit, `examples/monit/resque.monit` is provided free
of charge. This is **not** used by GitHub in production, so please
send patches for any tweaks or improvements you can make to it.


## Questions

Please add them to the [FAQ](https://github.com/resque/resque/wiki/FAQ) or
ask on the Mailing List. The Mailing List is explained further below


## Development

Want to hack on Resque?

First clone the repo and run the tests:

    git clone git://github.com/resque/resque.git
    cd resque
    rake test

If the tests do not pass make sure you have Redis installed
correctly (though we make an effort to tell you if we feel this is the
case). The tests attempt to start an isolated instance of Redis to
run against.

Also make sure you've installed all the dependencies correctly. For
example, try loading the `redis-namespace` gem after you've installed
it:

    $ irb
    >> require 'rubygems'
    => true
    >> require 'redis/namespace'
    => true

If you get an error requiring any of the dependencies, you may have
failed to install them or be seeing load path issues.

Feel free to ping the mailing list with your problem and we'll try to
sort it out.


## Contributing

Read the [Contributing][cb] wiki page first.

Once you've made your great commits:

1. [Fork][1] Resque
2. Create a topic branch - `git checkout -b my_branch`
3. Push to your branch - `git push origin my_branch`
4. Create a [Pull Request](http://help.github.com/pull-requests/) from your branch
5. That's it!


## Mailing List

To join the list simply send an email to <resque@librelist.com>. This
will subscribe you and send you information about your subscription,
including unsubscribe information.

The archive can be found at <http://librelist.com/browser/resque/>.


## Meta

* Code: `git clone git://github.com/resque/resque.git`
* Home: <http://github.com/resque/resque>
* Docs: <http://rubydoc.info/gems/resque>
* Bugs: <http://github.com/resque/resque/issues>
* List: <resque@librelist.com>
* Chat: <irc://irc.freenode.net/resque>
* Gems: <http://gemcutter.org/gems/resque>

This project uses [Semantic Versioning][sv].


## Author

Chris Wanstrath :: chris@ozmm.org :: @defunkt

[0]: http://github.com/blog/542-introducing-resque
[1]: http://help.github.com/forking/
[2]: http://github.com/resque/resque/issues
[sv]: http://semver.org/
[rs]: http://github.com/resque/redis-namespace
[cb]: http://wiki.github.com/resque/resque/contributing


## 后记

本该周末(1月31左右)学习的东西，结果，周末禁不住的看了两天动漫，感觉很不好。我的自控力果然是一坨烂泥。
