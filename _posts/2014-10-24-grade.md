---
layout: post
title: 关于Grape
---

## 缘起
----
近来，想要研究一下API编写的正确方式。

在学习gitlab源代码时，了解到其API是使用Grape编写的，恰好有想要编写API的任务，顺便研究一下如何编写RESTful的API。这年头，REST可是个时髦的词，最为一个年轻的程序员，当然是喜欢新的东西，新的思想，最新的框架，新的开放方式，新的Gem包。

下文是对Grape项目Readme文件的翻译。

## 目录

- [What is Grape?](#what-is-grape)
- [Stable Release](#stable-release)
- [Project Resources](#project-resources)
- [Installation](#installation)
- [Basic Usage](#basic-usage)
- [Mounting](#mounting)
  - [Rack](#rack)
  - [Alongside Sinatra (or other frameworks)](#alongside-sinatra-or-other-frameworks)
  - [Rails](#rails)
  - [Modules](#modules)
- [Versioning](#versioning)
  - [Path](#path)
  - [Header](#header)
  - [Accept-Version Header](#accept-version-header)
  - [Param](#param)
- [Describing Methods](#describing-methods)
- [Parameters](#parameters)
- [Parameter Validation and Coercion](#parameter-validation-and-coercion)
  - [Built-in Validators](#built-in-validators)
  - [Namespace Validation and Coercion](#namespace-validation-and-coercion)
  - [Custom Validators](#custom-validators)
  - [Validation Errors](#validation-errors)
  - [I18n](#i18n)
- [Headers](#headers)
- [Routes](#routes)
- [Helpers](#helpers)
- [Parameter Documentation](#parameter-documentation)
- [Cookies](#cookies)
- [HTTP Status Code](#http-status-code)
- [Redirecting](#redirecting)
- [Allowed Methods](#allowed-methods)
- [Raising Exceptions](#raising-exceptions)
  - [Default Error HTTP Status Code](#default-error-http-status-code)
  - [Handling 404](#handling-404)
- [Exception Handling](#exception-handling)
  - [Rails 3.x](#rails-3x)
- [Logging](#logging)
- [API Formats](#api-formats)
  - [JSONP](#jsonp)
  - [CORS](#cors)
- [Content-type](#content-type)
- [API Data Formats](#api-data-formats)
- [RESTful Model Representations](#restful-model-representations)
  - [Grape Entities](#grape-entities)
  - [Hypermedia](#hypermedia)
  - [Rabl](#rabl)
  - [Active Model Serializers](#active-model-serializers)
- [Authentication](#authentication)
- [Describing and Inspecting an API](#describing-and-inspecting-an-api)
- [Current Route and Endpoint](#current-route-and-endpoint)
- [Before and After](#before-and-after)
- [Anchoring](#anchoring)
- [Writing Tests](#writing-tests)
  - [Writing Tests with Rack](#writing-tests-with-rack)
  - [Writing Tests with Rails](#writing-tests-with-rails)
  - [Stubbing Helpers](#stubbing-helpers)
- [Reloading API Changes in Development](#reloading-api-changes-in-development)
  - [Rails 3.x](#rails-3x)
- [Performance Monitoring](#performance-monitoring)
- [Contributing to Grape](#contributing-to-grape)
- [Hacking on Grape](#hacking-on-grape)
- [License](#license)
- [Copyright](#copyright)

## What is Grape?

Grape是一个拥有类似REST API的Ruby微型框架。它设计运行在Rack或补充现有Web应用框架如Rails或Sinatra，提供一种简单DSL来简化RESTful APIs开发。它已经内置支持一些常见约束，包括多重格式(multiple formats), 子域/前缀约束(subdomain/prefix restriction), 内容导向(content negotiation), 版本(versioning)等。

## Stable Release

You're reading the documentation for the next release of Grape, which should be 0.9.1.
Please read [UPGRADING](UPGRADING.md) when upgrading from a previous version.
The current stable release is [0.9.0](https://github.com/intridea/grape/blob/v0.9.0/README.md).

本文档是Grape的0.9.1发布版本的，之前的发布版是[0.9.0](https://github.com/intridea/grape/blob/v0.9.0/README.md)。在将grape升级到0.9.1之前，请阅读[升级](UPGRADING.md)。

## Project Resources

* Need help? [Grape Google Group](http://groups.google.com/group/ruby-grape)
* [Grape Wiki](https://github.com/intridea/grape/wiki)

## Installation

Grape是一个gem包，其安装命令如下:

    gem install grape

如果使用Bundler，将其添加到Gemfile中:

    gem 'grape'

然后运行`bundle install`.

## Basic Usage

Grape APIS是一个Rack应用程序(又是个啥玩意)，通过子类化`Grape::API`来实现。如下是模仿Twitter API的一个简单样例，其中展示了很多Grape的特性。

```ruby
module Twitter
  class API < Grape::API
    # 这里是关于格式约束
    version 'v1', using: :header, vendor: 'twitter'
    format :json
    prefix :api

    # helper中定义的两个函数是关于权限认证的，需要考虑的是如何将其继承到现有的devise中。
    helpers do
      def current_user
        @current_user ||= User.authorize!(env)
      end

      def authenticate!
        error!('401 Unauthorized', 401) unless current_user
      end
    end

    resource :statuses do
      desc "Return a public timeline."
      get :public_timeline do
        Status.limit(20)
      end

      desc "Return a personal timeline."
      get :home_timeline do
        authenticate!
        current_user.statuses.limit(20)
      end

      desc "Return a status."
      params do
        requires :id, type: Integer, desc: "Status id."
      end
      route_param :id do
        get do
          Status.find(params[:id])
        end
      end

      desc "Create a status."
      params do
        requires :status, type: String, desc: "Your status."
      end
      post do
        authenticate!
        Status.create!({
          user: current_user,
          text: params[:status]
        })
      end

      desc "Update a status."
      params do
        requires :id, type: String, desc: "Status ID."
        requires :status, type: String, desc: "Your status."
      end
      put ':id' do
        authenticate!
        current_user.statuses.find(params[:id]).update({
          user: current_user,
          text: params[:status]
        })
      end

      desc "Delete a status."
      params do
        requires :id, type: String, desc: "Status ID."
      end
      delete ':id' do
        authenticate!
        current_user.statuses.find(params[:id]).destroy
      end
    end
  end
end
```

## Mounting

### Rack

The above sample creates a Rack application that can be run from a rackup `config.ru` file
with `rackup`:

上面的样例创建了一个Rack应用程序，可以使用`rackup config.ru`运行程序，其中`config.ru`中内容如下:

```ruby
run Twitter::API
```

并且将响应如下的路由:

    GET /statuses/public_timeline(.json)
    GET /statuses/home_timeline(.json)
    GET /statuses/:id(.json)
    POST /statuses(.json)
    PUT /statuses/:id(.json)
    DELETE /statuses/:id(.json)

Grape will also automatically respond to HEAD and OPTIONS for all GET, and just OPTIONS for all other routes.

Grape将自动相应所有的GET请求的头部(HEAD)以及选项(OPTIONS)，其他的路由仅响应选项(OPTIONS)。

### Alongside Sinatra (or other frameworks)

If you wish to mount Grape alongside another Rack framework such as Sinatra, you can do so easily using
`Rack::Cascade`:

如果你想要将Grape挂载到其他的Rack框架中(比如Sinatra)，可以使用`Rack::Cascade`:

```ruby
# Example config.ru

require 'sinatra'
require 'grape'

class API < Grape::API
  get :hello do
    { hello: "world" }
  end
end

class Web < Sinatra::Base
  get '/' do
    "Hello world."
  end
end

use Rack::Session::Cookie
run Rack::Cascade.new [API, Web]
```

### Rails

Place API files into `app/api`. Rails expects a subdirectory that matches the name of the Ruby module and a file name that matches the name of the class. In our example, the file name location and directory for `Twitter::API` should be `app/api/twitter/api.rb`.

Rails中，将API文件放置`app/api`中。Rails希望子目录名可以匹配Ruby的模块名，文件名可以匹配类的名字。在上述例子中，`Twitter::API`的文件名和位置因该是`app/api/twitter/api.rb`。

修改`application.rb`文件:

```ruby
config.paths.add File.join('app', 'api'), glob: File.join('**', '*.rb')
config.autoload_paths += Dir[Rails.root.join('app', 'api', '*')]
```

修改`config/routes`:

```ruby
mount Twitter::API => '/'
```

Additionally, if the version of your Rails is 4.0+ and the application uses the default model layer of ActiveRecord, you will want to use the `hashie_rails` [gem](http://rubygems.org/gems/hashie_rails). This gem disables the security feature of `strong_params` at the model layer, allowing you the use of Grape's own params validation instead.

此外，如果使用Rails 4.0+并且启动了ActiveRecord的默认模型层。可能需要使用`hashie_rails` [gem](http://rubygems.org/gems/hashie_rails)。该gem禁止了模型层`strong_params`的默认安全属性，从而使用Grape自身的参数验证。

```ruby
# Gemfile
gem "hashie_rails"
```

下文给出在开发环境中的附加代码，其启动修改API实现后重新加载。

### Modules

可以将多个API实现挂载到同一个模块中，其中的模块不一定要是API的不同版本，也可以是相同API的不同组件。

```ruby
class Twitter::API < Grape::API
  mount Twitter::APIv1
  mount Twitter::APIv2
end
```

You can also mount on a path, which is similar to using `prefix` inside the mounted API itself.

也可以将其挂载到一个路径中，这和在API内部挂载使用前缀类似。

```ruby
class Twitter::API < Grape::API
  mount Twitter::APIv1 => '/v1'
end
```

## Versioning

There are four strategies in which clients can reach your API's endpoints: `:path`,
`:header`, `:accept_version_header` and `:param`. The default strategy is `:path`.

存在四种不同的策略，使得客户端可以到达API的终端点： `:path`, `:header`, `:accept_version_header`和`:param`。老实说，不太明白为何称为四种策略。

### Path

```ruby
version 'v1', using: :path
```

使用版本策略，客户端可以在URL中传递想要版本号:

    curl -H http://localhost:9292/v1/statuses/public_timeline

> API的测试方法: Web中，测试API的方法存在很多中，比如POSTMan插件，RSpec，以及curl工具。其中，[curl](https://github.com/bagder/curl)是一个非常灵活、强大的工具，可以定制HTTP头信息，User Agent，支持所有HTTP动词。难怪，原来curl是这么NB的工具啊。

### Header

```ruby
version 'v1', using: :header, vendor: 'twitter'
```

使用版本策略，客户端可以在HTTP的`Accept`头部传递所需的版本，示例如下:

    curl -H Accept:application/vnd.twitter-v1+json http://localhost:9292/statuses/public_timeline

默认情况下，如果没有`Accept`头部，将会使用第一个匹配的版本。这中行为类似Rails中的路由。可使用`:strict`选项覆盖默认行为，将其`:strict`设置为true时，如果请求没提供正确的`Accept`，就会返回`406 Not Acceptable`错误。

提供非法的`Accept`头部时，如果设置`:cascade`为false时，就会返回`406 Not Acceptable`错误; 否则，如果Rack找不到匹配的路由就会返回`404 Not Found`错误。

### HTTP Status Code

默认情况下，Grape对`GET`请求返回200的状态码，`POST`请求返回201的状态吗。可使用`status`变量来查询并设置实际的HTTP状态码。

```ruby
post do
  status 202

  if status == 200
     # do some thing
  end
end
```

### Accept-Version Header

```ruby
version 'v1', using: :accept_version_header
```

在使用版本策略时，客户端应该在HTTP的`Accept-Version`头部包含所需的版本信息，示例如下:

    curl -H "Accept-Version:v1" http://localhost:9292/statuses/public_timeline

默认情况下，如果没有提供`Accept-Version`请求头提供，就使用第一个匹配的版本。其行为和Rails路由类似。可使用`:strict`选项覆盖默认行为，将其`:strict`设置为true时，如果请求没提供正确的`Accept`，就会返回`406 Not Acceptable`错误。

### Param

```ruby
version 'v1', using: :param
```

Using this versioning strategy, clients should pass the desired version as a request parameter,
either in the URL query string or in the request body.

使用版本策略，客户端需要将版本信息放置在请求参数中，示例如下:

    curl -H http://localhost:9292/statuses/public_timeline?apiver=v1

版本信息的请求参数的默认名为'apiver', 但是可以使用`:parameter`参数来指定。

```ruby
version 'v1', using: :param, parameter: "v"
```

测试命令: 

    curl -H http://localhost:9292/statuses/public_timeline?v=v1

## Describing Methods

可以在API方法和命名空间中添加一段描述。

```ruby
desc "Returns your public timeline." do
  detail 'more details'
  params  API::Entities::Status.documentation
  success API::Entities::Entity
  failure [[401, 'Unauthorized', "Entities::Error"]]
  named 'My named route'
  headers [XAuthToken: {
             description: 'Valdates your identity',
             required: true
           },
           XOptionalHeader: {
             description: 'Not really needed',
            required: false
           }
          ]
end
get :public_timeline do
  Status.limit(20)
end
```

* `detail`: 增强版的描述
* `params`: 直接从`Entity`中定义的参数 
* `success`: (former entity) The `Entity` to be used to present by default this route
* `failure`: (former http_codes) A definition of the used failure HTTP Codes and Entities
* `named`: 辅助方法-在文档哈希中找出给定路由名的元素
* `headers`: 使用头部的定义A definition of the used Headers

## Parameters

Request parameters are available through the `params` hash object. This includes `GET`, `POST`
and `PUT` parameters, along with any named parameters you specify in your route strings.

请求参数可通过`params`hash对象获取。其中包含了`GET`, `POST`, `PUT`参数，以及在路由字符串中指定的任何命名参数(比如，:id)。

```ruby
get :public_timeline do
  Status.order(params[:sort_by])
end
```

POST的请求体，PUT的表单输入、JSON数据以及XML内容类型都将自动解析成参数。

请求示例: 

```
curl -d '{"text": "140 characters"}' 'http://localhost:9292/statuses' -H Content-Type:application/json -v
```

对应的Grape终端节点:

```ruby
post '/statuses' do
  Status.create!(text: params[:text])
end
```

Grape支持多个部分的POSTs和PUTs，话说，多部分的POSTs和PUTs是啥？

请求示例，其中，@image是一个Ruby示例变量，回想curl支持组合工具，irb中也可执行命令行。

```
curl --form image_file=@image.jpg http://localhost:9292/upload
```

Grape终端代码:

```ruby
post "upload" do
  # file in params[:image_file]
end
```

In the case of conflict between either of:

在引起冲突情况下，参数的优先级顺序如下，其中路由字符串(route string parameters)优先级最高: 

* 路由字符串参数
* `GET`, `POST`和`PUT`参数
* `POST`和`PUT`的请求体中的内容

## 参数验证和强制 Parameter Validation and Coercion

You can define validations and coercion options for your parameters using a `params` block.

可以在`params`块定义验证和强制选项:

```ruby
params do
  requires :id, type: Integer
  optional :text, type: String, regexp: /^[a-z]+$/
  group :media do
    requires :url
  end
  optional :audio do
    requires :format, type: Symbol, values: [:mp3, :wav, :aac, :ogg], default: :mp3
  end
  mutually_exclusive :media, :audio  # 两个参数相互排斥
end
put ':id' do
  # params[:id] is an Integer
end
```

When a type is specified an implicit validation is done after the coercion to ensure the output type is the one declared.

类型指定是一种隐性的验证，从而强制输出类型为申明的类型。

可选参数可以具有默认值: 

```ruby
params do
  optional :color, type: String, default: 'blue'
  optional :random_number, type: Integer, default: -> { Random.rand(1..100) }
  optional :non_random_number, type: Integer, default:  Random.rand(1..100)
end
```

Note that default values will be passed through to any validation options specified.
The following example will always fail if `:color` is not expliclity provided.

**注意**: 任何指定的验证选项都可以设置默认值。如下实例中，如果`:color`没有显示指定，请求就总是返回失败。

```ruby
params do
  optional :color, type: String, default: 'blue', values: ['red', 'green']
end
```

The correct implementation is to ensure the default value passes all validations.

正确的做法是，确保默认值也要传递给所有的验证选项。

```ruby
params do
  optional :color, type: String, default: 'blue', values: ['blue', 'red', 'green']
end
```

#### Validation of Nested Parameters

Parameters can be nested using `group` or by calling `requires` or `optional` with a block.
In the above example, this means `params[:media][:url]` is required along with `params[:id]`,
and `params[:audio][:format]` is required only if `params[:audio]` is present.

参数可以使用`group`进行嵌套，或者以块为参数调用`requires`或者`optional`。例如，在上面例子中，`params[:media][:url]`伴随着`params[:id]`，当提供`params[:audio]`时，才需要提供`params[:audio][:format]`。

With a block, `group`, `requires` and `optional` accept an additional option `type` which can
be either `Array` or `Hash`, and defaults to `Array`. Depending on the value, the nested
parameters will be treated either as values of a hash or as values of hashes in an array.

在代码块中，`group`, `requires`和`optional`接受一个附加的`type`选项，其值可以是`Array`或`Hash`，但默认是`Array`。 根据该类型，嵌套的参数可被看作哈希中的哈希，或者数组中的哈希元素。

```ruby
params do
  optional :preferences, type: Array do
    requires :key
    requires :value
  end

  requires :name, type: Hash do
    requires :first_name
    requires :last_name
  end
end
```

### 内建验证(Built-in Validators)

#### `allow_blank`

Parameters can be defined as `allow_blank`, ensuring that they contain a value. By default, `requires`
only validates that a parameter was sent in the request, regardless its value. With `allow_blank`,
empty values or whitespace only values are invalid.

参数可以定义为`allow_blank`(允许为空)，确保其总是包包含值。默认情况下，`requires`仅仅验证参数否是包含在请求中，而不管其值。使用`allow_blank`时，空值和空白被看作为非法。

`allow_blank` can be combined with both `requires` and `optional`. If the parameter is required, it has to contain
a value. If it's optional, it's possible to not send it in the request, but if it's being sent, it has to have
some value, and not an empty string/only whitespaces.

`allow_blank`可以和`requires`和`optional`组合使用。如果提供了参数，就必须包含值。如果它是可选的，可能请求中没有提供相应的参数。一旦提供了相应的参数，就必须非空(即不是空字符串/空格)

```ruby
params do
  requires :username, allow_blank: false
  optional :first_name, allow_blank: false
end
```

#### `values`

Parameters can be restricted to a specific set of values with the `:values` option.

参数可以通过`:values`选项设定的一组值来限定。

Default values are eagerly evaluated. Above `:non_random_number` will evaluate to the same
number for each call to the endpoint of this `params` block. To have the default evaluate
at calltime use a lambda, like `:random_number` above.

```ruby
params do
  requires :status, type: Symbol, values: [:not_started, :processing, :done]
end
```

The `:values` option can also be supplied with a `Proc` to be evalutated at runtime. For example, given a status
model you may want to restrict by hashtags that you have previously defined in the `HashTag` model.

`:values`选项支持在运行时求值的`Proc`。例如，对于给定的status模型，可能想要使用先前定义的`HashTag`模型来限定。

```ruby
params do
  requires :hashtag, type: String, values: -> { Hashtag.all.map(&:tag) }
end
```

#### `regexp`

Parameters can be restricted to match a specific regular expression with the `:regexp` option. If the value
is nil or does not match the regular expression an error will be returned. Note that this is true for both `requires`
and `optional` parameters.

参数也可以通过`:regexp`选项，通过匹配特定的正则表达式来限制。如果值为nil或者不能匹配正则表达式，就会返回为错误。该选项对`requires`和`optional`参数均有效。

```ruby
params do
  requires :email, regexp: /.+@.+/
end
```

#### `mutually_exclusive`

Parameters can be defined as `mutually_exclusive`, ensuring that they aren't present at the same time in a request.

```ruby
params do
  optional :beer
  optional :wine
  mutually_exclusive :beer, :wine
end
```

Multiple sets can be defined:

```ruby
params do
  optional :beer
  optional :wine
  mutually_exclusive :beer, :wine
  optional :scotch
  optional :aquavit
  mutually_exclusive :scotch, :aquavit
end
```

**警告**: 不要对必须的参数定义互斥设置。两个互斥的必须参数，将表明params永远wuxiao，这使得API终端无效。必须参数和可选参数是互斥的，意味着可选参数总是无效的。

#### `exactly_one_of`

Parameters can be defined as 'exactly_one_of', ensuring that exactly one parameter gets selected.

```ruby
params do
  optional :beer
  optional :wine
  exactly_one_of :beer, :wine
end
```

#### `at_least_one_of`

Parameters can be defined as 'at_least_one_of', ensuring that at least one parameter gets selected.

```ruby
params do
  optional :beer
  optional :wine
  optional :juice
  at_least_one_of :beer, :wine, :juice
end
```

#### Nested `mutually_exclusive`, `exactly_one_of`, `at_least_one_of`

All of these methods can be used at any nested level.

```ruby
params do
  requires :food do
    optional :meat
    optional :fish
    optional :rice
    at_least_one_of :meat, :fish, :rice
  end
  group :drink do
    optional :beer
    optional :wine
    optional :juice
    exactly_one_of :beer, :wine, :juice
  end
  optional :dessert do
    optional :cake
    optional :icecream
    mutually_exclusive :cake, :icecream
  end
end
```

### 名称空间的验证和约束(Namespace Validation and Coercion)

Namespaces allow parameter definitions and apply to every method within the namespace.

```ruby
namespace :statuses do
  params do
    requires :user_id, type: Integer, desc: "A user ID."
  end
  namespace ":user_id" do
    desc "Retrieve a user's status."
    params do
      requires :status_id, type: Integer, desc: "A status ID."
    end
    get ":status_id" do
      User.find(params[:user_id]).statuses.find(params[:status_id])
    end
  end
end
```

The `namespace` method has a number of aliases, including: `group`, `resource`,
`resources`, and `segment`. Use whichever reads the best for your API.

`namespace`方法存在很多别名，包括`group`, `resource`,`resources` 和 `segment`。在API中，使用读起来最顺畅的哪个。

You can conveniently define a route parameter as a namespace using `route_param`.

使用`route_param`选项，可以方便的将路由参数定义为名称空间。

```ruby
namespace :statuses do
  route_param :id do
    desc "Returns all replies for a status."
    get 'replies' do
      Status.find(params[:id]).replies
    end
    desc "Returns a status."
    get do
      Status.find(params[:id])
    end
  end
end
```

### 定义验证器(Custom Validators)

```ruby
class AlphaNumeric < Grape::Validations::Validator
  def validate_param!(attr_name, params)
    unless params[attr_name] =~ /^[[:alnum:]]+$/
      raise Grape::Exceptions::Validation, params: [@scope.full_name(attr_name)], message: "must consist of alpha-numeric characters"
    end
  end
end
```

```ruby
params do
  requires :text, alpha_numeric: true
end
```
> 注意：上面的使用和定义的标准格式

You can also create custom classes that take parameters.

```ruby
class Length < Grape::Validations::SingleOptionValidator
  def validate_param!(attr_name, params)
    unless params[attr_name].length <= @option
      raise Grape::Exceptions::Validation, params: [@scope.full_name(attr_name)], message: "must be at the most #{@option} characters long"
    end
  end
end
```

```ruby
params do
  requires :text, length: 140
end
```

### Validation Errors

Validation and coercion errors are collected and an exception of type `Grape::Exceptions::ValidationErrors` is raised. If the exception goes uncaught it will respond with a status of 400 and an error message. The validation errors are grouped by parameter name and can be accessed via `Grape::Exceptions::ValidationErrors#errors`.

验证和约束错误都可以被收集，然后抛出`Grape::Exceptions::ValidationErrors`异常。如果异常没有被捕获，将会相应400状态码以及一个错误消息。验证错误以参数名作为分组，并且可以通过方法`Grape::Exceptions::ValidationErrors#errors`来访问。

The default response from a `Grape::Exceptions::ValidationErrors` is a humanly readable string, such as "beer, wine are mutually exclusive", in the following example.

`Grape::Exceptions::ValidationErrors`默认的相应格式是可读的。例如，如下的示例中，将会返回"beer, wine are mutually exclusive"这样的错误信息。

```ruby
params do
  optional :beer
  optional :wine
  optional :juice
  exactly_one_of :beer, :wine, :juice
end
```

You can rescue a `Grape::Exceptions::ValidationErrors` and respond with a custom response or turn the response into well-formatted JSON for a JSON API that separates individual parameters and the corresponding error messages. The following `rescue_from` example produces `[{"params":["beer","wine"],"messages":["are mutually exclusive"]}]`.

可以捕获异常`Grape::Exceptions::ValidationErrors`，然后更改为特定的相应，或者将响应转换为JSON格式(即分离单个参数以及对应的错误消息)。下面的例子中，`rescue_from`将会生成`[{"params":["beer","wine"],"messages":["are mutually exclusive"]}]`格式的响应。

```ruby
format :json
subject.rescue_from Grape::Exceptions::ValidationErrors do |e|
  rack_response e.to_json, 400
end
```

### I18n

Grape supports I18n for parameter-related error messages, but will fallback to English if
translations for the default locale have not been provided. See [en.yml](lib/grape/locale/en.yml) for message keys.

Grape针对参数相关的错误详细支持I18n，但是如果对应的本土化的文件没有提供，就会回退为英语。更多键信息参考[en.yml](https://github.com/intridea/grape/blob/master/lib/grape/locale/en.yml)。

## Headers

Request headers are available through the `headers` helper or from `env` in their original form.

请求头部可以通过`headers`头部获取，或从`env`获取其原本形式。

```ruby
get do
  error!('Unauthorized', 401) unless headers['Secret-Password'] == 'swordfish'
end
```

```ruby
get do
  error!('Unauthorized', 401) unless env['HTTP_SECRET_PASSWORD'] == 'swordfish'
end
```

You can set a response header with `header` inside an API.

可以在API中，以`header`参数设置响应头。

```ruby
header 'X-Robots-Tag', 'noindex'
```

When raising `error!`, pass additional headers as arguments.

当`error!`抛出异常时，传递附加的头作为参数。

```ruby
error! 'Unauthorized', 401, 'X-Error-Detail' => 'Invalid token.'
```

## Routes

Optionally, you can define requirements for your named route parameters using regular
expressions on namespace or endpoint. The route will match only if all requirements are met.

可选的，可以对命名路由参数使用正则表达式，从而定义相应的要求。路由将仅匹配那些满足要求的相应。

```ruby
get ':id', requirements: { id: /[0-9]*/ } do
  Status.find(params[:id])
end

namespace :outer, requirements: { id: /[0-9]*/ } do
  get :id do
  end

  get ":id/edit" do
  end
end
```

## Helpers

You can define helper methods that your endpoints can use with the `helpers`
macro by either giving a block or a module.

将代码块或模块传递给`helpers`宏，从而对endpoint定义辅助方法。

```ruby
module StatusHelpers
  def user_info(user)
    "#{user} has statused #{user.statuses} status(s)"
  end
end

class API < Grape::API
  # define helpers with a block
  helpers do
    def current_user
      User.find(params[:user_id])
    end
  end

  # or mix in a module
  helpers StatusHelpers

  get 'info' do
    # helpers available in your endpoint and filters
    user_info(current_user)
  end
end
```

You can define reusable `params` using `helpers`.

也可以通过`helpers`定义可重用的`params`。

```ruby
class API < Grape::API
  helpers do
    params :pagination do
      optional :page, type: Integer
      optional :per_page, type: Integer
    end
  end

  desc "Get collection"
  params do
    use :pagination # aliases: includes, use_scope
  end
  get do
    Collection.page(params[:page]).per(params[:per_page])
  end
end
```

You can also define reusable `params` using shared helpers.

使用共享帮助方法，可以定义可重用的`params`。

```ruby
module SharedParams
  extend Grape::API::Helpers

  params :period do
    optional :start_date
    optional :end_date
  end

  params :pagination do
    optional :page, type: Integer
    optional :per_page, type: Integer
  end
end

class API < Grape::API
  helpers SharedParams

  desc "Get collection."
  params do
    use :period, :pagination
  end

  get do
    Collection
      .from(params[:start_date])
      .to(params[:end_date])
      .page(params[:page])
      .per(params[:per_page])
  end
end
```

Helpers support blocks that can help set default values. The following API can return a collection sorted by `id` or `created_at` in `asc` or `desc` order.

Helpers支持可以设置默认值的块。如下的API将返回以`id`或`created_at`排序，或升序或降序的集合。

```ruby
module SharedParams
  extend Grape::API::Helpers

  params :order do |options|
    optional :order_by, type:Symbol, values:options[:order_by], default:options[:default_order_by]
    optional :order, type:Symbol, values:%i(asc desc), default:options[:default_order]
  end
end

class API < Grape::API
  helpers SharedParams

  desc "Get a sorted collection."
  params do
    use :order, order_by:%i(id created_at), default_order_by: :created_at, default_order: :asc
  end

  get do
    Collection.send(params[:order], params[:order_by])
  end
end
```

## Parameter Documentation

使用`documentation`哈希，可以添加附加的文档到`params`对象中。

```ruby
params do
  optional :first_name, type: String, documentation: { example: 'Jim' }
  requires :last_name, type: String, documentation: { example: 'Smith' }
end
```

## Cookies

通过cookies方法，可以方便的获取，设置，删除cookies。

```ruby
class API < Grape::API
  get 'status_count' do
    cookies[:status_count] ||= 0
    cookies[:status_count] += 1
    { status_count: cookies[:status_count] }
  end

  delete 'status_count' do
    { status_count: cookies.delete(:status_count) }
  end
end
```

使用基于哈希的语法，可以同时设置多个值。

```ruby
cookies[:status_count] = {
  value: 0,
  expires: Time.tomorrow,
  domain: '.twitter.com',
  path: '/'
}

cookies[:status_count][:value] +=1
```

Delete a cookie with `delete`.

```ruby
cookies.delete :status_count
```

Specify an optional path.

```ruby
cookies.delete :status_count, path: '/'
```

## Redirecting

You can redirect to a new url temporarily (302) or permanently (301).

`redirect`可以临时重定向到一个新的URL(302)，或者永久的重定向到一个新的URL(301)。

```ruby
redirect '/statuses'
```

```ruby
redirect '/statuses', permanent: true
```

## Allowed Methods

当为某个资源添加`GET`路由时，`HEAD`路由也会默认自动添加。可以通过`do_not_route_head!`方法禁止该行为。

``` ruby
class API < Grape::API
  do_not_route_head!

  get '/example' do
    # only responds to GET
  end
end
```

当为资源添加路由时，路由的`OPTIONS`方法也会自动添加。OPTIONS请求的相应将会包含所列出所有支持方法的`Allow`头部。

```ruby
class API < Grape::API
  get '/rt_count' do
    { rt_count: current_user.rt_count }
  end

  params do
    requires :value, type: Integer, desc: 'Value to add to the rt count.'
  end
  put '/rt_count' do
    current_user.rt_count += params[:value].to_i
    { rt_count: current_user.rt_count }
  end
end
```

```sh
curl -v -X OPTIONS http://localhost:3000/rt_count

> OPTIONS /rt_count HTTP/1.1
>
< HTTP/1.1 204 No Content
< Allow: OPTIONS, GET, PUT
```

同样，上述行为可以通过`do_not_route_options!`方法禁止。

If a request for a resource is made with an unsupported HTTP method, an HTTP 405 (Method Not Allowed) response will be returned.

如果使用不支持的HTTP方法发送请求，则会返回HTTP 405(方法未找到)的响应。

```sh
curl -X DELETE -v http://localhost:3000/rt_count/

> DELETE /rt_count/ HTTP/1.1
> Host: localhost:3000
>
< HTTP/1.1 405 Method Not Allowed
< Allow: OPTIONS, GET, PUT
```

## Raising Exceptions

使用`error!`方法抛出错误，可以终端API方法的执行。

```ruby
error! 'Access Denied', 401
```

You can also return JSON formatted objects by raising error! and passing a hash instead of a message.

抛出异常时，传递给error!方法一组哈希参数，可以返回JSON格式的对象。

```ruby
error!({ error: "unexpected error", detail: "missing widget" }, 500)
```

You can present documented errors with a Grape entity using the the [grape-entity](https://github.com/intridea/grape-entity) gem.

使用[grape-entity](https://github.com/intridea/grape-entity) gem 包，可以Grape entity来呈现文档化的错误。

```ruby
module API
  class Error < Grape::Entity
    expose :code
    expose :message
  end
end
```

The following example specifies the entity to use in the `http_codes` definition.

下面的例子中，实体使用了`http_codes`定义中的实体。

```
desc 'My Route' do
 failure [[408, 'Unauthorized', API::Error]]
end
error!({ message: 'Unauthorized' }, 408)
```

The following example specifies the presented entity explicitly in the error message.

```ruby
desc 'My Route' do
 failure [[408, 'Unauthorized']]
end
error!({ message: 'Unauthorized', with: API::Error }, 408)
```

### Default Error HTTP Status Code

By default Grape returns a 500 status code from `error!`. You can change this with `default_error_status`.

默认情况下，Grape中`error!`方法返回500的状态码。可以通过`default_error_status`选项修改默认行为。

``` ruby
class API < Grape::API
  default_error_status 400
  get '/example' do
    error! "This should have http status code 400"
  end
end
```

### Handling 404

For Grape to handle all the 404s for your API, it can be useful to use a catch-all.
In its simplest form, it can be like:

Grape自动为API处理所有的404请求，使用catch-all非常有用。其最简形式如下:

```ruby
route :any, '*path' do
  error! # or something else
end
```

It is very crucial to __define this endpoint at the very end of your API__, as it literally accepts every request.

在API最后定义这么一段代码非常有用，它确实可以接受每一个请求。

## 异常处理(Exception Handling)

Grape can be told to rescue all exceptions and return them in the API format.

Grape可以处理所有异常并以API形式返回。

```ruby
class Twitter::API < Grape::API
  rescue_from :all
end
```

也可以指定处理特定的异常。

```ruby
class Twitter::API < Grape::API
  rescue_from ArgumentError, UserDefinedError
end
```

上述情况下，`UserDefinedError`必须继承自`StandardError`。其错误的格式要匹配请求的格式，具体参考下面的"Content-Types"。

Custom error formatters for existing and additional types can be defined with a proc.

可以在proc中为已存的或附加的类型定制错误格式化器。

```ruby
class Twitter::API < Grape::API
  error_formatter :txt, lambda { |message, backtrace, options, env|
    "error: #{message} from #{backtrace}"
  }
end
```

除了proc，也可使用module或class。

```ruby
module CustomFormatter
  def self.call(message, backtrace, options, env)
    { message: message, backtrace: backtrace }
  end
end

class Twitter::API < Grape::API
  error_formatter :custom, CustomFormatter
end
```

You can rescue all exceptions with a code block. The `error_response` wrapper
automatically sets the default error code and content-type.

```ruby
class Twitter::API < Grape::API
  rescue_from :all do |e|
    error_response({ message: "rescued from #{e.class.name}" })
  end
end
```

You can also rescue specific exceptions with a code block and handle the Rack response at the lowest level.



```ruby
class Twitter::API < Grape::API
  rescue_from :all do |e|
    Rack::Response.new([ e.message ], 500, { "Content-type" => "text/error" }).finish
  end
end
```

Or rescue specific exceptions.

```ruby
class Twitter::API < Grape::API
  rescue_from ArgumentError do |e|
    Rack::Response.new([ "ArgumentError: #{e.message}" ], 500).finish
  end
  rescue_from NotImplementedError do |e|
    Rack::Response.new([ "NotImplementedError: #{e.message}" ], 500).finish
  end
end
```

By default, `rescue_from` will rescue the exceptions listed and all their subclasses.

Assume you have the following exception classes defined.

```ruby
module APIErrors
  class ParentError < StandardError; end
  class ChildError < ParentError; end
end
```

Then the following `rescue_from` clause will rescue exceptions of type `APIErrors::ParentError` and its subclasses (in this case `APIErrors::ChildError`).

```ruby
rescue_from APIErrors::ParentError do |e|
    Rack::Response.new({
      error: "#{e.class} error",
      message: e.message
      }.to_json, e.status).finish
end
```

To only rescue the base exception class, set `rescue_subclasses: false`.
The code below will rescue exceptions of type `RuntimeError` but _not_ its subclasses.

```ruby
rescue_from RuntimeError, rescue_subclasses: false do |e|
    Rack::Response.new({
      status: e.status,
      message: e.message,
      errors: e.errors
      }.to_json, e.status).finish
end
```

#### Rails 3.x

When mounted inside containers, such as Rails 3.x, errors like "404 Not Found" or
"406 Not Acceptable" will likely be handled and rendered by Rails handlers. For instance,
accessing a nonexistent route "/api/foo" raises a 404, which inside rails will ultimately
be translated to an `ActionController::RoutingError`, which most likely will get rendered
to a HTML error page.

Most APIs will enjoy preventing downstream handlers from handling errors. You may set the
`:cascade` option to `false` for the entire API or separately on specific `version` definitions,
which will remove the `X-Cascade: true` header from API responses.

```ruby
cascade false
```

```ruby
version 'v1', using: :header, vendor: 'twitter', cascade: false
```

## Logging

`Grape::API` provides a `logger` method which by default will return an instance of the `Logger`
class from Ruby's standard library.

To log messages from within an endpoint, you need to define a helper to make the logger
available in the endpoint context.

```ruby
class API < Grape::API
  helpers do
    def logger
      API.logger
    end
  end
  post '/statuses' do
    # ...
    logger.info "#{current_user} has statused"
  end
end
```

You can also set your own logger.

```ruby
class MyLogger
  def warning(message)
    puts "this is a warning: #{message}"
  end
end

class API < Grape::API
  logger MyLogger.new
  helpers do
    def logger
      API.logger
    end
  end
  get '/statuses' do
    logger.warning "#{current_user} has statused"
  end
end
```

## API Formats

By default, Grape supports _XML_, _JSON_, _BINARY_, and _TXT_ content-types. The default format is `:txt`.

Serialization takes place automatically. For example, you do not have to call `to_json` in each JSON API implementation.

Your API can declare which types to support by using `content_type`. Response format is determined by the
request's extension, an explicit `format` parameter in the query string, or `Accept` header.

The following API will only respond to the JSON content-type and will not parse any other input than `application/json`,
`application/x-www-form-urlencoded`, `multipart/form-data`, `multipart/related` and `multipart/mixed`. All other requests
will fail with an HTTP 406 error code.

```ruby
class Twitter::API < Grape::API
  format :json
end
```

When the content-type is omitted, Grape will return a 406 error code unless `default_format` is specified.
The following API will try to parse any data without a content-type using a JSON parser.

```ruby
class Twitter::API < Grape::API
  format :json
  default_format :json
end
```

If you combine `format` with `rescue_from :all`, errors will be rendered using the same format.
If you do not want this behavior, set the default error formatter with `default_error_formatter`.

```ruby
class Twitter::API < Grape::API
  format :json
  content_type :txt, "text/plain"
  default_error_formatter :txt
end
```

Custom formatters for existing and additional types can be defined with a proc.

```ruby
class Twitter::API < Grape::API
  content_type :xls, "application/vnd.ms-excel"
  formatter :xls, lambda { |object, env| object.to_xls }
end
```

You can also use a module or class.

```ruby
module XlsFormatter
  def self.call(object, env)
    object.to_xls
  end
end

class Twitter::API < Grape::API
  content_type :xls, "application/vnd.ms-excel"
  formatter :xls, XlsFormatter
end
```

Built-in formats are the following.

* `:json`: use object's `to_json` when available, otherwise call `MultiJson.dump`
* `:xml`: use object's `to_xml` when available, usually via `MultiXml`, otherwise call `to_s`
* `:txt`: use object's `to_txt` when available, otherwise `to_s`
* `:serializable_hash`: use object's `serializable_hash` when available, otherwise fallback to `:json`
* `:binary`

Use `default_format` to set the fallback format when the format could not be determined from the `Accept` header.
See below for the order for choosing the API format.

```ruby
class Twitter::API < Grape::API
  default_format :json
end
```

The order for choosing the format is the following.

* Use the file extension, if specified. If the file is .json, choose the JSON format.
* Use the value of the `format` parameter in the query string, if specified.
* Use the format set by the `format` option, if specified.
* Attempt to find an acceptable format from the `Accept` header.
* Use the default format, if specified by the `default_format` option.
* Default to `:txt`.

You can override this process explicitly by specifying `env['api.format']` in the API itself.
For example, the following API will let you upload arbitrary files and return their contents as an attachment with the correct MIME type.

```ruby
class Twitter::API < Grape::API
  post "attachment" do
    filename = params[:file][:filename]
    content_type MIME::Types.type_for(filename)[0].to_s
    env['api.format'] = :binary # there's no formatter for :binary, data will be returned "as is"
    header "Content-Disposition", "attachment; filename*=UTF-8''#{URI.escape(filename)}"
    params[:file][:tempfile].read
  end
end
```

### JSONP

Grape supports JSONP via [Rack::JSONP](https://github.com/rack/rack-contrib), part of the
[rack-contrib](https://github.com/rack/rack-contrib) gem. Add `rack-contrib` to your `Gemfile`.

```ruby
require 'rack/contrib'

class API < Grape::API
  use Rack::JSONP
  format :json
  get '/' do
    'Hello World'
  end
end
```

### CORS

Grape supports CORS via [Rack::CORS](https://github.com/cyu/rack-cors), part of the
[rack-cors](https://github.com/cyu/rack-cors) gem. Add `rack-cors` to your `Gemfile`,
then use the middleware in your config.ru file.

```ruby
require 'rack/cors'

use Rack::Cors do
  allow do
    origins '*'
    resource '*', headers: :any, methods: :get
  end
end

run Twitter::API

```

## Content-type

Content-type is set by the formatter. You can override the content-type of the response at runtime
by setting the `Content-Type` header.

```ruby
class API < Grape::API
  get '/home_timeline_js' do
    content_type "application/javascript"
    "var statuses = ...;"
  end
end
```

## API Data Formats

Grape accepts and parses input data sent with the POST and PUT methods as described in the Parameters
section above. It also supports custom data formats. You must declare additional content-types via
`content_type` and optionally supply a parser via `parser` unless a parser is already available within
Grape to enable a custom format. Such a parser can be a function or a class.

With a parser, parsed data is available "as-is" in `env['api.request.body']`.
Without a parser, data is available "as-is" and in `env['api.request.input']`.

The following example is a trivial parser that will assign any input with the "text/custom" content-type
to `:value`. The parameter will be available via `params[:value]` inside the API call.

```ruby
module CustomParser
  def self.call(object, env)
    { value: object.to_s }
  end
end
```

```ruby
content_type :txt, "text/plain"
content_type :custom, "text/custom"
parser :custom, CustomParser

put "value" do
  params[:value]
end
```

You can invoke the above API as follows.

```
curl -X PUT -d 'data' 'http://localhost:9292/value' -H Content-Type:text/custom -v
```

You can disable parsing for a content-type with `nil`. For example, `parser :json, nil` will disable JSON parsing altogether. The request data is then available as-is in `env['api.request.body']`.

## RESTful Model Representations

Grape supports a range of ways to present your data with some help from a generic `present` method,
which accepts two arguments: the object to be presented and the options associated with it. The options
hash may include `:with`, which defines the entity to expose.

### Grape Entities

Add the [grape-entity](https://github.com/intridea/grape-entity) gem to your Gemfile.
Please refer to the [grape-entity documentation](https://github.com/intridea/grape-entity/blob/master/README.md)
for more details.

The following example exposes statuses.

```ruby
module API
  module Entities
    class Status < Grape::Entity
      expose :user_name
      expose :text, documentation: { type: "string", desc: "Status update text." }
      expose :ip, if: { type: :full }
      expose :user_type, :user_id, if: lambda { |status, options| status.user.public? }
      expose :digest { |status, options| Digest::MD5.hexdigest(status.txt) }
      expose :replies, using: API::Status, as: :replies
    end
  end

  class Statuses < Grape::API
    version 'v1'

    desc 'Statuses index' do
      params: API::Entities::Status.documentation
    end
    get '/statuses' do
      statuses = Status.all
      type = current_user.admin? ? :full : :default
      present statuses, with: API::Entities::Status, type: type
    end
  end
end
```

You can use entity documentation directly in the params block with `using: Entity.documentation`.

```ruby
module API
  class Statuses < Grape::API
    version 'v1'

    desc 'Create a status'
    params do
      requires :all, except: [:ip], using: API::Entities::Status.documentation.except(:id)
    end
    post '/status' do
      Status.create! params
    end
  end
end
```

You can present with multiple entities using an optional Symbol argument.

```ruby
  get '/statuses' do
    statuses = Status.all.page(1).per(20)
    present :total_page, 10
    present :per_page, 20
    present :statuses, statuses, with: API::Entities::Status
  end
```

The response will be

```
  {
    total_page: 10,
    per_page: 20,
    statuses: []
  }
```

In addition to separately organizing entities, it may be useful to put them as namespaced
classes underneath the model they represent.

```ruby
class Status
  def entity
    Entity.new(self)
  end

  class Entity < Grape::Entity
    expose :text, :user_id
  end
end
```

If you organize your entities this way, Grape will automatically detect the `Entity` class and
use it to present your models. In this example, if you added `present Status.new` to your endpoint,
Grape will automatically detect that there is a `Status::Entity` class and use that as the
representative entity. This can still be overridden by using the `:with` option or an explicit
`represents` call.

### Hypermedia and Roar

You can use [Roar](https://github.com/apotonick/roar) to render HAL or Collection+JSON with the help of [grape-roar](https://github.com/dblock/grape-roar), which defines a custom JSON formatter and enables presenting entities with Grape's `present` keyword.

### Rabl

You can use [Rabl](https://github.com/nesquena/rabl) templates with the help of the
[grape-rabl](https://github.com/LTe/grape-rabl) gem, which defines a custom Grape Rabl
formatter.

### Active Model Serializers

You can use [Active Model Serializers](https://github.com/rails-api/active_model_serializers) serializers with the help of the
[grape-active_model_serializers](https://github.com/jrhe/grape-active_model_serializers) gem, which defines a custom Grape AMS
formatter.


## Authentication

### Basic and Digest Auth

Grape has built-in Basic and Digest authentication (the given `block`
is executed in the context of the current `Endpoint`).  Authentication
applies to the current namespace and any children, but not parents.

```ruby
http_basic do |username, password|
  # verify user's password here
  { 'test' => 'password1' }[username] == password
end
```

```ruby
http_digest({ realm: 'Test Api', opaque: 'app secret' }) do |username|
  # lookup the user's password here
  { 'user1' => 'password1' }[username]
end
```

### Register custom middleware for authentication

Grape can use custom Middleware for authentication. How to implement these
Middleware have a look at `Rack::Auth::Basic` or similar implementations.


For registering a Middleware you need the following options:

* `label` - the name for your authenticator to use it later
* `MiddlewareClass` - the MiddlewareClass to use for authentication
* `option_lookup_proc` - A Proc with one Argument to lookup the options at
runtime (return value is an `Array` as Paramter for the Middleware).

Example:

```ruby

Grape::Middleware::Auth::Strategies.add(:my_auth, AuthMiddleware, ->(options) { [options[:realm]] } )


auth :my_auth ,{ real: 'Test Api'} do |credentials|
  # lookup the user's password here
  { 'user1' => 'password1' }[username]
end

```

Use [warden-oauth2](https://github.com/opperator/warden-oauth2) or [rack-oauth2](https://github.com/nov/rack-oauth2) for OAuth2 support.

## Describing and Inspecting an API

Grape routes can be reflected at runtime. This can notably be useful for generating
documentation.

Grape exposes arrays of API versions and compiled routes. Each route
contains a `route_prefix`, `route_version`, `route_namespace`, `route_method`,
`route_path` and `route_params`. The description and the optional hash that
follows the API path may contain any number of keys and its values are also
accessible via dynamically-generated `route_[name]` functions.

```ruby
TwitterAPI::versions # yields [ 'v1', 'v2' ]
TwitterAPI::routes # yields an array of Grape::Route objects
TwitterAPI::routes[0].route_version # yields 'v1'
TwitterAPI::routes[0].route_description # etc.
```

## Current Route and Endpoint

It's possible to retrieve the information about the current route from within an API
call with `route`.

```ruby
class MyAPI < Grape::API
  desc "Returns a description of a parameter."
  params do
    requires :id, type: Integer, desc: "Identity."
  end
  get "params/:id" do
    route.route_params[params[:id]] # yields the parameter description
  end
end
```

The current endpoint responding to the request is `self` within the API block
or `env['api.endpoint']` elsewhere. The endpoint has some interesting properties,
such as `source` which gives you access to the original code block of the API
implementation. This can be particularly useful for building a logger middleware.

```ruby
class ApiLogger < Grape::Middleware::Base
  def before
    file = env['api.endpoint'].source.source_location[0]
    line = env['api.endpoint'].source.source_location[1]
    logger.debug "[api] #{file}:#{line}"
  end
end
```

## Before and After

Blocks can be executed before or after every API call, using `before`, `after`,
`before_validation` and `after_validation`.

Before and after callbacks execute in the following order:

1. `before`
2. `before_validation`
3. _validations_
4. `after_validation`
5. _the API call_
6. `after`

Steps 4, 5 and 6 only happen if validation succeeds.

E.g. using `before`:

```ruby
before do
  header "X-Robots-Tag", "noindex"
end
```

The block applies to every API call within and below the current namespace:

```ruby
class MyAPI < Grape::API
  get '/' do
    "root - #{@blah}"
  end

  namespace :foo do
    before do
      @blah = 'blah'
    end

    get '/' do
      "root - foo - #{@blah}"
    end

    namespace :bar do
      get '/' do
        "root - foo - bar - #{@blah}"
      end
    end
  end
end
```

The behaviour is then:

```bash
GET /           # 'root - '
GET /foo        # 'root - foo - blah'
GET /foo/bar    # 'root - foo - bar - blah'
```

Params on a `namespace` (or whatever alias you are using) also work when using
`before_validation` or `after_validation`:

```ruby
class MyAPI < Grape::API
  params do
    requires :blah, type: Integer
  end
  resource ':blah' do
    after_validation do
      # if we reach this point validations will have passed
      @blah = declared(params, include_missing: false)[:blah]
    end

    get '/' do
      @blah.class
    end
  end
end
```

The behaviour is then:

```bash
GET /123        # 'Fixnum'
GET /foo        # 400 error - 'blah is invalid'
```

## Anchoring

Grape by default anchors all request paths, which means that the request URL
should match from start to end to match, otherwise a `404 Not Found` is
returned. However, this is sometimes not what you want, because it is not always
known upfront what can be expected from the call. This is because Rack-mount by
default anchors requests to match from the start to the end, or not at all.
Rails solves this problem by using a `anchor: false` option in your routes.
In Grape this option can be used as well when a method is defined.

For instance when your API needs to get part of an URL, for instance:

```ruby
class TwitterAPI < Grape::API
  namespace :statuses do
    get '/(*:status)', anchor: false do

    end
  end
end
```

This will match all paths starting with '/statuses/'. There is one caveat though:
the `params[:status]` parameter only holds the first part of the request url.
Luckily this can be circumvented by using the described above syntax for path
specification and using the `PATH_INFO` Rack environment variable, using
`env["PATH_INFO"]`. This will hold everything that comes after the '/statuses/'
part.

## Writing Tests

You can test a Grape API with RSpec by making HTTP requests and examining the response.

### Writing Tests with Rack

Use `rack-test` and define your API as `app`.

```ruby
require 'spec_helper'

describe Twitter::API do
  include Rack::Test::Methods

  def app
    Twitter::API
  end

  describe Twitter::API do
    describe "GET /api/statuses/public_timeline" do
      it "returns an empty array of statuses" do
        get "/api/statuses/public_timeline"
        expect(last_response.status).to eq(200)
        expect(JSON.parse(last_response.body)).to eq []
      end
    end
    describe "GET /api/statuses/:id" do
      it "returns a status by id" do
        status = Status.create!
        get "/api/statuses/#{status.id}"
        expect(last_response.body).to eq status.to_json
      end
    end
  end
end
```

### Writing Tests with Rails

```ruby
describe Twitter::API do
  describe "GET /api/statuses/public_timeline" do
    it "returns an empty array of statuses" do
      get "/api/statuses/public_timeline"
      expect(response.status).to eq(200)
      expect(JSON.parse(response.body)).to eq []
    end
  end
  describe "GET /api/statuses/:id" do
    it "returns a status by id" do
      status = Status.create!
      get "/api/statuses/#{status.id}"
      expect(response.body).to eq status.to_json
    end
  end
end
```

In Rails, HTTP request tests would go into the `spec/requests` group. You may want your API code to go into
`app/api` - you can match that layout under `spec` by adding the following in `spec/spec_helper.rb`.

```ruby
RSpec.configure do |config|
  config.include RSpec::Rails::RequestExampleGroup, type: :request, file_path: /spec\/api/
end
```

### Stubbing Helpers

Because helpers are mixed in based on the context when an endpoint is defined, it can
be difficult to stub or mock them for testing. The `Grape::Endpoint.before_each` method
can help by allowing you to define behavior on the endpoint that will run before every
request.

```ruby
describe 'an endpoint that needs helpers stubbed' do
  before do
    Grape::Endpoint.before_each do |endpoint|
      endpoint.stub(:helper_name).and_return('desired_value')
    end
  end

  after do
    Grape::Endpoint.before_each nil
  end

  it 'should properly stub the helper' do
    # ...
  end
end
```

## Reloading API Changes in Development

### Rails 3.x

Add API paths to `config/application.rb`.

```ruby
# Auto-load API and its subdirectories
config.paths.add File.join("app", "api"), glob: File.join("**", "*.rb")
config.autoload_paths += Dir[Rails.root.join("app", "api", "*")]
```

Create `config/initializers/reload_api.rb`.

```ruby
if Rails.env.development?
  ActiveSupport::Dependencies.explicitly_unloadable_constants << "Twitter::API"

  api_files = Dir[Rails.root.join('app', 'api', '**', '*.rb')]
  api_reloader = ActiveSupport::FileUpdateChecker.new(api_files) do
    Rails.application.reload_routes!
  end
  ActionDispatch::Callbacks.to_prepare do
    api_reloader.execute_if_updated
  end
end
```

See [StackOverflow #3282655](http://stackoverflow.com/questions/3282655/ruby-on-rails-3-reload-lib-directory-for-each-request/4368838#4368838) for more information.

## Performance Monitoring

Grape integrates with NewRelic via the
[newrelic-grape](https://github.com/flyerhzm/newrelic-grape) gem, and
with Librato Metrics with the [grape-librato](https://github.com/seanmoon/grape-librato) gem.

## Contributing to Grape

Grape is work of hundreds of contributors. You're encouraged to submit pull requests, propose
features and discuss issues.

See [CONTRIBUTING](CONTRIBUTING.md).

## Hacking on Grape

You can start hacking on Grape on
[Nitrous.IO](https://www.nitrous.io/?utm_source=github.com&utm_campaign=grape&utm_medium=hackonnitrous) in a matter of seconds:

[![Hack intridea/grape on Nitrous.IO](https://d3o0mnbgv6k92a.cloudfront.net/assets/hack-l-v1-3cc067e71372f6045e1949af9d96095b.png)](https://www.nitrous.io/hack_button?source=embed&runtime=rails&repo=intridea%2Fgrape&file_to_open=README.md)

## License

MIT License. See LICENSE for details.
