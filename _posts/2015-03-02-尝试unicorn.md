---
layout: post
title: 尝试Unicorn
description: "unicorn, ruby web服务器，socket"
---

## 前言

想尝试一下Unicorn，就使用公司最小的项目mobile试了一下，或者使用[wlog](https://github.com/windy/wblog)这个晚上随便找的项目。

## 正文

mobile的项目无从下手，所以，尝试wlog一半成功了。

```
RAILS_ENV=production rake db:setup
RAILS_ENV=production rake assets:precompile
```

Nginx的配置文件: 

```
upstream wblog {
  server unix:/tmp/unicorn_wblog.sock fail_timeout=0;
}

server {
  listen 80;
  server_name 192.168.1.239;
  root /home/ruby/wblog/current/public; # 注意这里不是项目的根目录，而是根目录下的public目录

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  location ~ ^/(uploads)/  {
    expires max;
    break;
  }

  try_files $uri/index.html $uri @wblog;
  location @wblog {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://wblog;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 20M;
  keepalive_timeout 10;
}
```

unicorn的配置文件:

```
app_path = "/home/ruby/wblog/current"

worker_processes   1
preload_app        true
timeout            180
listen             '/tmp/unicorn_wblog.sock'
user               'ruby', 'ruby'
working_directory  app_path
pid                "#{app_path}/tmp/pids/unicorn_wblog.pid"
stderr_path        "log/unicorn.log"
stdout_path        "log/unicorn.log"

before_fork do |server, worker|
    old_pid = "#{server.config[:pid]}.oldbin"
    if File.exists?(old_pid) && server.pid != old_pid
      begin
        Process.kill("QUIT", File.read(old_pid).to_i)
      rescue Errno::ENOENT, Errno::ESRCH
        # someone else did our job for us
      end
    end
end

after_fork do |server, worker|
end
```

启动unicorn： `unicorn_rails -c config/unicorn/production.rb -D -E production`

> 备注： 花了点钱升级了服务器的内存，结果需要重启服务器，重启服务器时，发现了一个问题，unicorn没有设置开机自启动，有机会设置一下。

无缝重启: `kill -USR2 $(cat tmp/pids/unicorn_wblog.pid)`

遇到的问题: 

```
$ rake assets:precompile 
rake aborted!
NameError: uninitialized constant Rack::Cors
```

解决： 启动环境的问题。设置`RAILS_ENV=production`即可。后来，预编译失败了，是由于Fundation-rails的版本引起的，将版本由`5.5.0`切换为`5.4.5.0`，就能正常的编译了。

```
$ RAILS_ENV=production rake db:setup
rake aborted!
Moped::Errors::ConnectionFailure: Could not connect to a primary node for replica set #<Moped::Cluster:97556630 @seeds=[<Moped::Node resolved_address="127.0.1.1:27017">]>
```

解决： mongodb连接的问题，mongodb.conf中配置的是127.0.0.1, 应用程序中连接的是127.0.1.1。在`mongoid.yml`中将localhost修改为127.0.0.1即可。

```
production:
  sessions:
    default:
      database: w_blog_production
      hosts:
        - 127.0.0.1:27017
```

实践初步完成，接下来进行性能测试。

## ab测试

ab测试的命令: `ab -n1000 -c10 http://115.28.165.58:5000/`

unicorn的配置为: 

```
worker_processes   1
preload_app        true
timeout            180
```

本地测试结果: 


```
Document Path:          /
Document Length:        5082 bytes

Concurrency Level:      10
Time taken for tests:   67.273 seconds
Complete requests:      1000
Failed requests:        835  # 这里的失败的请求数可能是由于重启Unicron的原因
   (Connect: 0, Receive: 0, Length: 835, Exceptions: 0)
Total transferred:      8858950 bytes
HTML transferred:       8044580 bytes
Requests per second:    14.86 [#/sec] (mean)
Time per request:       672.725 [ms] (mean)
Time per request:       67.273 [ms] (mean, across all concurrent requests)
Transfer rate:          128.60 [Kbytes/sec] received
```

远程主机测试结果(仅考虑Rails框架的动态处理能力): 

```
Document Path:          /
Document Length:        8630 bytes

Concurrency Level:      10
Time taken for tests:   21.336 seconds
Complete requests:      1000
Failed requests:        0
Total transferred:      9448000 bytes
HTML transferred:       8630000 bytes
Requests per second:    46.87 [#/sec] (mean)
Time per request:       213.356 [ms] (mean)
Time per request:       21.336 [ms] (mean, across all concurrent requests)
Transfer rate:          432.45 [Kbytes/sec] received
```

> 备注: 发现Rails的动态处理能力还是可以接受的，并发数为10时，能处理46.87个请求，性能还是可以的。

将Unicorn的工作进程数设置为2时，结果如下: 

```
# 远程服务器测试
Document Path:          /
Document Length:        8630 bytes

Concurrency Level:      10
Time taken for tests:   25.578 seconds
Complete requests:      1000
Failed requests:        141
   (Connect: 0, Receive: 0, Length: 141, Exceptions: 0)
Total transferred:      8951772 bytes
HTML transferred:       8136830 bytes
Requests per second:    39.10 [#/sec] (mean)
Time per request:       255.782 [ms] (mean)
Time per request:       25.578 [ms] (mean, across all concurrent requests)
Transfer rate:          341.77 [Kbytes/sec] received

# 本地测试
Concurrency Level:      10
Time taken for tests:   73.114 seconds
Complete requests:      1000
Failed requests:        0
Total transferred:      9448000 bytes
HTML transferred:       8630000 bytes
Requests per second:    13.68 [#/sec] (mean)
Time per request:       731.143 [ms] (mean)
Time per request:       73.114 [ms] (mean, across all concurrent requests)
Transfer rate:          126.19 [Kbytes/sec] received
```

看到服务器动态内容处理要比本地响应的请求慢很多，想到服务器本地测试可以作为Rails动态内容处理的速率上限。于是乎，
我对比了正式和测试服务器，发现正式服务器请求处理：14 req/s 对 11 req/s ，测试服务器上是 71.91 req/s 对 11.74 req/s， 
由于测试服务器是将mysql，mongodb、nginx以及应用服务器等都安装在一台机器上。

于是，猜想：**可能是由于不合理的分布式架构引起的性能的质降**。之后的事情就是要验证的这个猜想，这就需要做一些其他相关的事情。

> 注： 某日将数据库服务器分离后，测试服务器上的ab测试的结果为: 27.39 req/s 对11.09 req/s，果然是不合里的分布式数据库引起的
> 处理量的下降。或者说，服务器内网之间数据传送延迟较大。

## 后记

原本，就不是特别熟悉unicorn等之类的web应用服务器，搞了一圈。Passegner就不熟悉，还去搞更不熟悉的unicorn，
判断失误了。 后来，还是搞起来了。

## 参考文献

1. [Nginx + Unicorn 部署 Rails 完整配置](http://blog.csdn.net/menxu_work/article/details/17077617)
2. [rails部署nginx+unicorn详解](http://www.mojidong.com/rails/2013/04/20/rails-nginx-unicorn/)
2. [Ruby-China.org 选择用 Thin 还是 Unicorn?](https://ruby-china.org/topics/35)
3. [使用Nginx + unicorn搭建ruby on rails的生产环境](http://my.oschina.net/mogralee/blog/299890)
