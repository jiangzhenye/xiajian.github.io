---
layout: post
title: 尝试Unicorn
description: "unicorn, ruby web服务器，socket"
---

## 前言

想尝试一下Unicorn，就使用公司最小的项目mobile试了一下，或者使用[wlog](https://github.com/windy/wblog)这个晚上随便找的项目。

## 正文

mobile的项目无从下手，所以，尝试wlog一半成功了。

RAILS_ENV=production rake db:setup
RAILS_ENV=production rake assets:precompile

Nginx的配置文件: 

```
upstream wblog {
  server unix:/tmp/unicorn_wblog.sock fail_timeout=0;
}

server {
  listen 80;
  server_name 192.168.1.239;
  root /home/ruby/wblog/current/public; # 注意这里不是项目的根目录，而是根目录下的public目录

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  location ~ ^/(uploads)/  {
    expires max;
    break;
  }

  try_files $uri/index.html $uri @wblog;
  location @wblog {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://wblog;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 20M;
  keepalive_timeout 10;
}
```

unicorn的配置文件:

```
app_path = "/home/ruby/wblog/current"

worker_processes   1
preload_app        true
timeout            180
listen             '/tmp/unicorn_wblog.sock'
user               'ruby', 'ruby'
working_directory  app_path
pid                "#{app_path}/tmp/pids/unicorn_wblog.pid"
stderr_path        "log/unicorn.log"
stdout_path        "log/unicorn.log"

before_fork do |server, worker|
    old_pid = "#{server.config[:pid]}.oldbin"
    if File.exists?(old_pid) && server.pid != old_pid
      begin
        Process.kill("QUIT", File.read(old_pid).to_i)
      rescue Errno::ENOENT, Errno::ESRCH
        # someone else did our job for us
      end
    end
end

after_fork do |server, worker|
end
```

启动unicorn： `unicorn_rails -c /config/unicorn/unicorn.rb -D -E production`

无缝重启: `kill -USR2 $(cat tmp/pids/unicorn_wblog.pid)`


遇到的问题: 

```
$ rake assets:precompile 
rake aborted!
NameError: uninitialized constant Rack::Cors
```

解决： 启动环境的问题。设置`RAILS_ENV=production`即可。

```
$ RAILS_ENV=production rake db:setup
rake aborted!
Moped::Errors::ConnectionFailure: Could not connect to a primary node for replica set #<Moped::Cluster:97556630 @seeds=[<Moped::Node resolved_address="127.0.1.1:27017">]>
```

解决： mongodb连接的问题，mongodb.conf中配置的是127.0.0.1, 应用程序中连接的是127.0.1.1。在`mongoid.yml`中将localhost修改为127.0.0.1即可。

```
production:
  sessions:
    default:
      database: w_blog_production
      hosts:
        - 127.0.0.1:27017
```

实践初步完成，接下来进行性能测试。

## ab测试

ab测试的命令: `ab -n1000 -c10 http://115.28.165.58:5000/`

unicorn的配置为: 

```
worker_processes   1
preload_app        true
timeout            180
```

本地测试结果: 


```
Document Path:          /
Document Length:        5082 bytes

Concurrency Level:      10
Time taken for tests:   67.273 seconds
Complete requests:      1000
Failed requests:        835  # 这里的失败的请求数可能是由于重启Unicron的原因
   (Connect: 0, Receive: 0, Length: 835, Exceptions: 0)
Total transferred:      8858950 bytes
HTML transferred:       8044580 bytes
Requests per second:    14.86 [#/sec] (mean)
Time per request:       672.725 [ms] (mean)
Time per request:       67.273 [ms] (mean, across all concurrent requests)
Transfer rate:          128.60 [Kbytes/sec] received
```

远程主机测试结果(仅考虑Rails框架的动态处理能力): 

```
Document Path:          /
Document Length:        8630 bytes

Concurrency Level:      10
Time taken for tests:   21.336 seconds
Complete requests:      1000
Failed requests:        0
Total transferred:      9448000 bytes
HTML transferred:       8630000 bytes
Requests per second:    46.87 [#/sec] (mean)
Time per request:       213.356 [ms] (mean)
Time per request:       21.336 [ms] (mean, across all concurrent requests)
Transfer rate:          432.45 [Kbytes/sec] received
```


将Unicorn的工作进程数设置为2时，结果如下: 

```
# 远程服务器测试
Document Path:          /
Document Length:        8630 bytes

Concurrency Level:      10
Time taken for tests:   25.578 seconds
Complete requests:      1000
Failed requests:        141
   (Connect: 0, Receive: 0, Length: 141, Exceptions: 0)
Total transferred:      8951772 bytes
HTML transferred:       8136830 bytes
Requests per second:    39.10 [#/sec] (mean)
Time per request:       255.782 [ms] (mean)
Time per request:       25.578 [ms] (mean, across all concurrent requests)
Transfer rate:          341.77 [Kbytes/sec] received

# 本地测试
Concurrency Level:      10
Time taken for tests:   73.114 seconds
Complete requests:      1000
Failed requests:        0
Total transferred:      9448000 bytes
HTML transferred:       8630000 bytes
Requests per second:    13.68 [#/sec] (mean)
Time per request:       731.143 [ms] (mean)
Time per request:       73.114 [ms] (mean, across all concurrent requests)
Transfer rate:          126.19 [Kbytes/sec] received
```

看到服务器动态内容处理要比本地响应的请求慢很多，想到服务器本地测试可以作为Rails动态内容处理的速率上限。于是乎，
我对比了正式服务器请求处理：14 req/s 对 11 req/s ，这说明，应用服务器本身的处理能力就是个问题。

测试服务器上是 71.91 req/s 对 11.74 req/s。


## 后记

原本，就不是特别熟悉unicorn等之类的web应用服务器，搞了一圈。Passegner就不熟悉，还去搞更不熟悉的unicorn，
判断失误了。
