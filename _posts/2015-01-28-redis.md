---
layout: post
title: 关于redis
---

## 前言

我终于找到时间研究Redis了，前一段时间居然去搞前端去了，感觉有点不自在。果然，server端才是自己的前进的方向，Rails，Redis，Mongodb之类的。

## redis-rb

[redis-rb](https://github.com/redis/redis-rb)是[Redis][http://redis.io]的ruby客户端。redis-rb客户端尝试一一匹配Redis的API，并提供地道
的接口。其具备线程安全、客户端分片、管道以及不错的性能。

从2.x升级到3.0, 不过，网站上使用的已经是最新的redis版本了。

## Getting started

2.0的客户端匹配2.0以上的Redis版本。如果想要使用2.0之前的redis实例，可以使用老的客户端(不再开发维护)。

连接Redis需要实例化`Redis`类。

```ruby
require "redis"

redis = Redis.new
```

这里假设Redis以默认配置启动，即监听`localhost`和6379端口。如果需要连接到远程服务器的不同端口，可以
这么做: 

```ruby
redis = Redis.new(:host => "10.0.1.1", :port => 6380, :db => 15)
```

当然，也可以通过URL来指定连接选项:

```ruby
redis = Redis.new(:url => "redis://:p4ssw0rd@10.0.1.1:6380/15")
```

默认情况下，客户端尝试读取`REDIS_URL`环境变量，并使用其中的值作为链接的URL。设置环境变量并
不带参的调用`Redis.new`，上述的语句功效是相同的。

通过Unix套接字连接Redis的设置，其效果如下:

```ruby
redis = Redis.new(:path => "/tmp/redis.sock")
```

连接带密码保护的Redis实例，可以使用:

```ruby
redis = Redis.new(:password => "mysecret")
```

Redis类提供的方法与所执行的命令名一致。这些方法接受的参数与命令接受的参数也一致，命令参数
的详细描述参考[Redis website](http://redis.io/commands)

```ruby
redis.set("mykey", "hello world")
# => "OK"

redis.get("mykey")
# => "hello world"
```

所有的命令、参数及其返回值都是被文档化的，并且可在 [rdoc.info](http://rdoc.info/github/redis/redis-rb/) 中查看。

## 哨兵支持(Sentinel support)

通过使用[Redis哨兵](http://redis.io/topics/sentinel)，客户端可以自动支持故障转义。

建立哨兵链接的命令如下: 

```ruby
SENTINELS = [{:host => "127.0.0.1", :port => 26380},
             {:host => "127.0.0.1", :port => 26381}]

redis = Redis.new(:url => "redis://mymaster", :sentinels => SENTINELS, :role => :master)
```

* master名指定了主从模型的一组Redis实例(例子中为`mymaster`)
* 可指定角色选项，其值可为`master`和`slave`。当角色为`slave`时，客户端将尝试连接到由特定master指定的随机slave中。
  如果没有指定角色，客户端将链接到master上。
* 使用哨兵支持需要指定链接的哨兵列表。列表中不需要枚举出所有的哨兵实例，但是必须确保，一个挂了后还能找到另一个替代
  客户端能记住上一个可正确应答的哨兵，并在下次请求时使用该哨兵。

## 对象保存(Storing objects)

Redis只能将字符串存储为值，如果想要保存对象，必须是使用某种序列化的机制，比如JSON:

```ruby
require "json"

redis.set "foo", [1, 2, 3].to_json
# => OK

JSON.parse(redis.get("foo"))
# => [1, 2, 3]
```

## 管道(Pipelining)

当多个命令顺序执行，且彼此依赖时，这叫**管道**。

When multiple commands are executed sequentially, but are not dependent,
the calls can be *pipelined*. This means that the client doesn't wait
for reply of the first command before sending the next command. The
advantage is that multiple commands are sent at once, resulting in
faster overall execution.

The client can be instructed to pipeline commands by using the
`#pipelined` method. After the block is executed, the client sends all
commands to Redis and gathers their replies. These replies are returned
by the `#pipelined` method.

```ruby
redis.pipelined do
  redis.set "foo", "bar"
  redis.incr "baz"
end
# => ["OK", 1]
```

### Executing commands atomically

You can use `MULTI/EXEC` to run a number of commands in an atomic
fashion. This is similar to executing a pipeline, but the commands are
preceded by a call to `MULTI`, and followed by a call to `EXEC`. Like
the regular pipeline, the replies to the commands are returned by the
`#multi` method.

```ruby
redis.multi do
  redis.set "foo", "bar"
  redis.incr "baz"
end
# => ["OK", 1]
```

### Futures

Replies to commands in a pipeline can be accessed via the *futures* they
emit (since redis-rb 3.0). All calls inside a pipeline block return a
`Future` object, which responds to the `#value` method. When the
pipeline has succesfully executed, all futures are assigned their
respective replies and can be used.

```ruby
redis.pipelined do
  @set = redis.set "foo", "bar"
  @incr = redis.incr "baz"
end

@set.value
# => "OK"

@incr.value
# => 1
```

## Error Handling

In general, if something goes wrong you'll get an exception. For example, if
it can't connect to the server a `Redis::CannotConnectError` error will be raised.

```ruby
begin
  redis.ping
rescue Exception => e
  e.inspect
# => #<Redis::CannotConnectError: Timed out connecting to Redis on 10.0.1.1:6380>

  e.message
# => Timed out connecting to Redis on 10.0.1.1:6380
end
```

See lib/redis/errors.rb for information about what exceptions are possible.


## Expert-Mode Options

 - `inherit_socket: true`: disable safety check that prevents a forked child
   from sharing a socket with its parent; this is potentially useful in order to mitigate connection churn when:
    - many short-lived forked children of one process need to talk
      to redis, AND
    - your own code prevents the parent process from using the redis
      connection while a child is alive

   Improper use of `inherit_socket` will result in corrupted and/or incorrect
   responses.

## Alternate drivers

By default, redis-rb uses Ruby's socket library to talk with Redis.
To use an alternative connection driver it should be specified as option
when instantiating the client object. These instructions are only valid
for **redis-rb 3.0**. For instructions on how to use alternate drivers from
**redis-rb 2.2**, please refer to an [older README][readme-2.2.2].

[readme-2.2.2]: https://github.com/redis/redis-rb/blob/v2.2.2/README.md

### hiredis

The hiredis driver uses the connection facility of hiredis-rb. In turn,
hiredis-rb is a binding to the official hiredis client library. It
optimizes for speed, at the cost of portability. Because it is a C
extension, JRuby is not supported (by default).

It is best to use hiredis when you have large replies (for example:
`LRANGE`, `SMEMBERS`, `ZRANGE`, etc.) and/or use big pipelines.

In your Gemfile, include hiredis:

```ruby
gem "redis", "~> 3.0.1"
gem "hiredis", "~> 0.4.5"
```

When instantiating the client object, specify hiredis:

```ruby
redis = Redis.new(:driver => :hiredis)
```

### synchrony

The synchrony driver adds support for [em-synchrony][em-synchrony].
This makes redis-rb work with EventMachine's asynchronous I/O, while not
changing the exposed API. The hiredis gem needs to be available as
well, because the synchrony driver uses hiredis for parsing the Redis
protocol.

[em-synchrony]: https://github.com/igrigorik/em-synchrony

In your Gemfile, include em-synchrony and hiredis:

```ruby
gem "redis", "~> 3.0.1"
gem "hiredis", "~> 0.4.5"
gem "em-synchrony"
```

When instantiating the client object, specify synchrony:

```ruby
redis = Redis.new(:driver => :synchrony)
```

## Testing

This library is tested using [Travis][travis-home], where it is tested
against the following interpreters and drivers:

* MRI 1.8.7 (drivers: ruby, hiredis)
* MRI 1.9.2 (drivers: ruby, hiredis, synchrony)
* MRI 1.9.3 (drivers: ruby, hiredis, synchrony)
* MRI 2.0.0 (drivers: ruby, hiredis, synchrony)
* JRuby 1.7 (1.8 mode) (drivers: ruby)
* JRuby 1.7 (1.9 mode) (drivers: ruby)

## 后记

学到一个git命令: `git shortlog -sn`查看项目贡献者的排名。
