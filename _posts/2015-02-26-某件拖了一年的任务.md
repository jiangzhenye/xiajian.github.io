---
layout: post
title: "某件拖了一年的任务"
description: "ruby, 任务"
---

## 前言

我成功的将一件任务，从去年年末拖到今天。将文章的中的股票名转换为链接。以下是一些代码的迭代: 

```ruby
# 第一版
$redis.sadd "stock:chinese_name" , Regexp.escape(Stock.only(:chinese_name).map(:chinese_name))
$redis.smembers("stock:chinese_name").each do |n|
  content.gsub(/n/).each do |x|
    st = Stock.where(chinese_name: n).first
    st ? "<strong><a href='/asset_class/stocks/#{st.slug}'>#{x}</a></strong>" : x
  end
end

# 第二版
$redis.sadd "stocks:chinese_name" , Stock.only(:chinese_name).map { |x| Regexp.escape(x.chinese_name) }
content.gsub(/[$redis.smembers("stocks:chinese_name").join("|")]/).each do |x|
  st = Stock.where(chinese_name: x).first
  st ? "<strong><a href='/asset_class/stocks/#{st.slug}'>#{x}</a></strong>" : x
end

# 输出失败, 打印了一下，看到转换成功了，看来是自己被检测输出给坑了，应该打印出来看看

# 重试正则表达式:

re = Regexp.new($redis.smembers("stocks:chinese_name").join("|"))
content.gsub(re).each do |x|
  p x
  st = Stock.where(chinese_name: x).first
  p "<strong><a href='/asset_class/stocks/#{st.slug}'>#{x}</a></strong>"
  st ? "<strong><a href='/asset_class/stocks/#{st.slug}'>#{x}</a></strong>" : x
end

content.gsub(/上汽集团|新华保险/).each do |x|
  st = Stock.where(chinese_name: x).first
  p "<strong><a href='/asset_class/stocks/#{st.slug}'>#{x}</a></strong>"
  st ? "<strong><a href='/asset_class/stocks/#{st.slug}'>#{x}</a></strong>" : x
end

# 最终版, views的辅助方法
def convert_stock_to_link(content)
  re = Regexp.new($redis.smembers("stocks:chinese_name").join("|"))
  content.gsub(re).each do |x|
    st = Stock.where(chinese_name: x).first
    # p "<strong><a href='/asset_class/stocks/#{st.slug}'>#{x}</a></strong>"
    st ? "<strong><a href='/asset_class/stocks/#{st.slug}' target='_blank'>#{x}</a></strong>" : x
  end
end
```

上面的代码性能不好，但是，实现最简单，调整思路，换了个复杂的方法实现。

```ruby
# 改变思路了，只要存个正则表达式字符串就行了，表达式构建如下: 
$redis.set "stocks:chinese_name:regexp" , Stock.only(:chinese_name).map { |x| Regexp.escape(x.chinese_name) }.uniq.join('|')
```
新的正则表达式式方法被前辈否决，回退过去。

原本，想尝试使用后台任务处理的，最后还是选择的简单易写的`before_save`回调:

```ruby
# 新的view辅助方法
def convert_stock_to_link(article)
  return article.content if article.stocks.nil?
  re = Regexp.new(article.stocks.only(:chinese_name).map { |x| Regexp.escape(x.chinese_name) }.join('|'))
  article.content.gsub(re).each do |x|
    st = Stock.where(chinese_name: x).first
    # p "<strong><a href='/asset_class/stocks/#{st.slug}'>#{x}</a></strong>"
    st ? "<a href='/asset_class/stocks/#{st.slug}' target='_blank' >#{x}</a>" : x
  end
end

# Article模型的before_save回调
class Article
  ...
  include Mongoid::Document
  has_and_belongs_to_many :stocks

  before_save :add_stocks

  private 
  
  def add_stocks
    if content_changed?
      re = Regexp.new($redis.smembers("stocks:chinese_name").join("|"))
      self.content.scan(re).each do |x|
        st = Stock.where(chinese_name: x).first
        self.stocks << st 
      end
    end
  end
  ....
end

# 创建的Rake任务，7千个文章，执行了半个小时，29万的话，大概要一天，我擦啊！！！
re = Regexp.new($redis.smembers("stocks:chinese_name").join("|"))
Article.each do |article|
  article.content.scan(re).each do |x|
    st = Stock.where(chinese_name: x).first
    article.stocks << st # 等价于 => articles.stocks.push st
  end
  article.save
end
```

## 后记

我还是觉得最初写的view辅助方法很好，很简洁，之后的实现要复杂的多。

哈哈，居然从年前拖到了年后，我还真是有才。
